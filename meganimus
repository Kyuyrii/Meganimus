#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

import sys
import os
import locale
import json
import toml
import subprocess
import atexit
import shutil
import requests
import tarfile
import io
import threading
import time
import psutil
import uuid
import re
import shlex
import random
from pathlib import Path
from functools import partial

# Translation System
try:
    locale.setlocale(locale.LC_ALL, '')
    LANG, _ = locale.getlocale(locale.LC_CTYPE)
except locale.Error:
    LANG = 'en_US'

if not LANG:
    LANG = 'en_US'

__version__ = "1.6.1.1"
__creator__ = "<a href='https://github.com/Kyuyrii'>Kyuyrii</a>"

BUILTIN_TRANSLATIONS = {
    'en_US': {
        "ABOUT_TEXT_HTML": """<b>Meganimus</b><br>
        Version: {__version__}<br><br>
        A launcher for native and emulator games.<br>
        License: <a href='https://www.gnu.org/licenses/gpl-3.0.html.en'>GPLv3</a><br>
        Created by {__creator__}""",
        "ABOUT_MEGANIMUS": "About Meganimus",
        "ADD_FILES": "Add files",
        "ADD_FOLDER": "Add folder",
        "ALREADY_UPDATED": "You are on the latest version.",
        "ALL_PORTALS": "All portals",
        "API_FAIL": "API error:<br>{error}",
        "API_KEY_SAVE_FIRST": "Save your API KEY in the Meganimus settings first.",
        "APPIMAGE_AND_EXECUTABLE": "AppImage/Executable",
        "APP_NAME": "Meganimus",
        "ARTS_LOAD_ERROR": "[DEBUG] Failed to load arts: {error}",
        "AUTO_TRANSFER_BUTTON": "Automatic mode",
        "AUTO_TRANSFER_EXPLAIN": "Do you want to try downloading hero artwork and icons for all the portals that don't have them?<br>After the download, they will be applied automatically.",
        "AUTO_TRANSFER_FINISHED": "Automatic transfer completed",
        "AUTO_TRANSFER_GENERAL_ERROR": "General error in {inv_name}: {error}",
        "AUTO_TRANSFER_NO_MISSING_ARTS": "All portals already have hero art and icon",
        "BROWSE_BUTTON": "Browse",
        "CHANGES_SAVED": "Changes have been saved.",
        "CHECK_UPDATE_BUTTON": "¿Update?",
        "CONFIRM_CLOSE_MESSAGE": "Do you want to end the current portal and close Meganimus?",
        "CONTENT": "Content",
        "CLOSE_MEGANIMUS": "Close Meganimus",
        "CREATE_PORTAL": "Create portal",
        "CREATE_MULTIPLE_PORTALS": "Create multiple portals",
        "CUSTOM_COMMAND": "Customizable command (Advanced)",
        "DEBUG_REAL_PORTAL_INITIATED": "[DEBUG] portal initiated as PID {pid}",
        "DEFAULT_QT_STYLE": "- System default -",
        "DELETE_PORTAL_CONFIRM_MESSAGE": "Are you sure you want to remove the portal '{name}'?",
        "DELETE_PORTALS_CONFIRM_MESSAGE": "Are you sure you want to remove the selected portals?",
        "DESELECT_ALL_IN_MULTIPLE_EDIT": "None",
        "DESKTOP_FOLDER": "Desktop folder",
        "DONE": "Done",
        "DO_NOT_CHANGE": "[Do not change]",
        "DUPLICATE_NAME_IN_LIST": "There is already another portal in the list with the name: {name}",
        "EDIT_MULTIPLE_PORTALS": "Edit multiple portal",
        "ENTER_GAME_NAME": "Enter a game name.",
        "ENVIRONMENT_VARS": "Variables",
        "ERROR": "Error",
        "ERROR_CREATING_FILE": "Error creating {file}: {error}",
        "ERROR_CREATING_SHORTCUTS_LOCATION": "This location could not be used:<br>{location}<br>Check its existence and permissions",
        "ERROR_EXECUTOR_APPIMAGE_NOT_FOUND": "AppImage/Executable not found at:<br>{path}",
        "ERROR_EXECUTOR_FLATPAK_NOT_FOUND": "The Flatpak '{name}' was not found on the system.",
        "ERROR_EXECUTOR_SNAP_NOT_FOUND": "The Snap '{name}' was not found on the system.",
        "ERROR_GAME_NOT_FOUND": "The game was not found at:<br>{path}",
        "ERROR_LOADING_FILE": "Error loading file {file}: {error}",
        "ERROR_MOVING_SHORTCUTS": "Error moving the .desktop files {file}: {error}",
        "ERROR_REMOVING_FILE": "Error removing {file}: {error}",
        "ERROR_TRANSFERRING_URL": "Error transferring {url}: {error}",
        "EXECUTORS": "Configurable executors",
        "EXECUTOR_ARGS": "Arguments",
        "EXECUTOR_COMMAND": "Command",
        "EXECUTOR_COMMAND_NOT_SET": "No defined command",
        "EXECUTOR_NOT_CONFIGURED": "Executor not configured",
        "EXECUTOR_PATH_NOT_SET": "No defined path",
        "EXECUTOR_VERSION": "Version",
        "EXECUTOR_VERSION_NOT_SELECTED": "You need to choose a version first.",
        "EXTRAS": "Extras",
        "EXTRACTING": "Extracting: {name}",
        "GAME_PATH": "Game",
        "FAILED_UPDATE_TOML": "Could not update portal information: {error}",
        "FILE": "File",
        "FOLDER": "Folder",
        "FPS_DXVK_HUD": "DXVK HUD (Only UMU)",
        "FPS_GALLIUM_HUD": "Gallium HUD (Not always compatible)",
        "GAMEMODE": "Use Feral gamemode",
        "ICON_TOOLBAR_SIZE": "Button size",
        "ICON_WIDTH_CLASSIC": "Icon size (Classic)",
        "ICON_WIDTH_GRID": "Icon size (Grid)",
        "IMAGE_FILTER": "Image Files (*.jpg *.jpeg *.png *.webp);;All Files (*)",
        "ISO_ALREADY_MOUNTED": "ISO is already mounted at {mount}",
        "ISO_MOUNT_DIR_REMOVED": "Mounted ISO directory removed: {mount}",
        "ISO_MOUNT_DIR_REMOVE_FAILED": "Failed to remove mounted ISO directory {mount}: {error}",
        "ISO_MOUNT_FAILED": "Failed to mount ISO {error}",
        "ISO_NOT_MOUNTED": "ISO is not mounted at {mount}",
        "ISO_UNMOUNTED": "ISO successfully unmounted from {mount}",
        "ISO_UNMOUNT_EXCEPTION": "Exception occurred while unmounting ISO: {error}",
        "ISO_UNMOUNT_FAILED": "Failed to unmount ISO at {mount}: {error}",
        "PORTAL": "Portal",
        "PORTAL_ALREADY_ACTIVE": "Close current portal and start the selected one?",
        "PORTAL_ALREADY_EXISTS": "There is already an portal with that name. Choose another.",
        "PORTAL_ARGS": "Arguments",
        "PORTAL_ART_PATH": "Art",
        "PORTAL_GUI_PATH": "Icon GUI",
        "PORTAL_INFO_ERROR": "Unable to access/execute the game or find information about this portal.",
        "PORTAL_INFO_LOADED": "Portal info loaded successfully for: {name}",
        "PORTAL_INFO_VIEWER_TITLE": "Portals information",
        "PORTAL_LANGUAGE": "Language (Locale)",
        "PORTAL_NAME": "Name",
        "PORTAL_IN_MULTIPLE_CREATE_ALREADY_EXISTS": "The portal '{name}' already exists, use another name.",
        "PORTAL_START_ERROR": "An error occurred while trying to start the portal: {error}",
        "PORTAL_STARTED": "Meganimus - Open portal: {portal_name}",
        "PS3_GAME_FOLDER_NOT_FOUND_IN_ISO": "PS3_GAME folder not found in ISO",
        "LANGUAGE": "Language",
        "LANGUAGE_SET_ERROR": "[Error] Failed to set LC_ALL: {error}",
        "LAYOUT_MODE": "Layout mode",
        "LAYOUT_MODE_CLASSIC": "Classic",
        "LAYOUT_MODE_GRID": "Grid",
        "LAYOUT_MODE_LIST": "List",
        "LOAD_HEROES": "Load heroes",
        "LOAD_ICONS": "Load icons",
        "MANAGE_SHORTCUTS": "Manage shortcuts",
        "MANDATORY_FIELDS_ERROR": "Name and game are required.",
        "MARK_LISTED": "Check listed",
        "MEGANIMUS_CLOSED": "Meganimus closed. Finalizing processes...",
        "MEGANIMUS_SETTINGS": "Meganimus preferences",
        "MEGANIMUS_TRAY_TOGGLE": "Change visibility",
        "MENU_FOLDER": "Menu folder",
        "MODIFY_PORTAL": "Modify portal",
        "MULTIPLE_PORTAL_EDITOR": "Multiple portal editor",
        "MULTIPLE_PORTAL_CREATOR": "Creator of multiple portals",
        "MULTIPLE_PORTAL_REMOVER": "Multiple portal remover",
        "NAME": "Name",
        "NAME_INVALID": "The name is invalid, select another.",
        "NAME_INVALID_IN_MULTIPLE": "The name '{name}' is invalid, select another.",
        "NEW_VERSION_AVAILABLE": "New version found: '{version}'.<br>Do you want to go to the repository?",
        "NO_BUTTON": "No",
        "NO_IMAGES": "No images found.",
        "NO_PORTAL_SELECTED_ERROR": "No portal selected.",
        "NO_PORTAL_SELECTED_MULTIPLE": "No portal selected",
        "NO_PORTALS_FOUND": "No portals were found.",
        "NO_PYQT6_FOUND_ERROR": "PyQt6 not found.",
        "NO_RESULTS": "No results.",
        "NO_TAGS_FOUND": "No tags found in the repository.",
        "OWN_CATEGORY": "Own category",
        "PLACEHOLDER_FOR_LANGUAGE": "- No language chosen -",
        "QT_STYLE": "QT style",
        "RESET_BUTTON_MULTIPLE_EDIT": "Reset",
        "REMOVE": "Remove",
        "REMOVE_MULTIPLE_PORTALS": "Remove multiple portals",
        "REMOVE_SELECTED": "Remove selected",
        "EXECUTOR": "Executor",
        "RUNNING_COMMAND": "Running command: {command}",
        "RUNNING_IN_BACKGROUND": "Started in the background",
        "SAVE_BUTTON": "Save",
        "SEE_DATA": "View data",
        "SEARCH": "Search",
        "SELECT": "Select",
        "SELECT_ALL_IN_MULTIPLE_EDIT": "All",
        "SELECT_AT_LEAST_ONE_IMAGE": "Select at least one image.",
        "SELECT_FILE": "Select file",
        "SELECT_FOLDER": "Select folder",
        "SELECT_GAME": "Select game",
        "SELECT_GAME_FOLDER": "Select game folder",
        "SELECT_PORTAL_ART": "Select art",
        "SELECT_VERSION": "- Select a version -",
        "SETTINGS_SAVED_RESTART": "Changes saved.<br>Restart Meganimus to apply visual changes.",
        "SGDB_API_KEY_LABEL": "SteamGridDB API Key",
        "SHORTCUTS_MANAGER_TITLE": "Shortcut Manager",
        "SHORTCUTS_OF_DESKTOP": "Desktop shortcuts",
        "SHORTCUTS_OF_MENU": "Menu shortcuts",
        "SHORTCUTS_PATHS": "Paths",
        "SHORTCUTS_SAVED": "Updated shortcuts",
        "SHOW_FPS_OPTION": "Show FPS",
        "SHOW_FPS_OPTION_HUD": "Selected HUD",
        "START": "Start",
        "START_PORTAL": "Start portal",
        "START_RANDOM_PORTAL": "Random portal",
        "STARTING_PORTAL": "Starting portal: {name}",
        "STOP_PORTAL": "Stop portal",
        "STOP_KILL_ERROR": "[Stop] Error killing process {pid}: {error}",
        "STOP_NO_PORTAL_ACTIVE": "[Stop] No portal active.",
        "STOP_NO_PROCESS_FOUND": "[Stop] No portal process found to terminate.",
        "STOP_PROCESS_SUCCESS": "[Stop] Process {pid} terminated successfully.",
        "TRANSFER": "Transfer",
        "TRANSFER_ARTS": "Arts",
        "TRANSFER_ARTS_TITLE": "Steamgriddb arts transfer",
        "TRANSFER_SUMMARY": "Transferred to:\n{dir}",
        "UNMARK_LISTED": "Uncheck listed",
        "UPDATE_ERROR": "Error checking for updates:\n{error}",
        "UPDATE_SHORTCUTS": "Update shortcuts",
        "USING_PYQT6": "Using PyQt6",
        "YES_BUTTON": "Yes",
    },
    'pt_BR': {
        "ABOUT_TEXT_HTML": """<b>Meganimus</b><br>
        Versão: {__version__}<br><br>
        Um launcher para jogos nativos e de emuladores.<br>
        Licença: <a href='https://www.gnu.org/licenses/gpl-3.0.html'>GPLv3</a><br>
        Criado por {__creator__}""",
        "ABOUT_MEGANIMUS": "Sobre o Meganimus",
        "ADD_FILES": "Adicionar arquivos",
        "ADD_FOLDER": "Adicionar pasta",
        "ALREADY_UPDATED": "Você está na versão mais recente.",
        "ALL_PORTALS": "Todos os portais",
        "API_FAIL": "Erro de API:<br>{error}",
        "API_KEY_SAVE_FIRST": "Salve sua API KEY nas configurações do Meganimus primeiro.",
        "APPIMAGE_AND_EXECUTABLE": "AppImage/Executável",
        "APP_NAME": "Meganimus",
        "ARTS_LOAD_ERROR": "[DEBUG] Falha ao carregar artes: {error}",
        "AUTO_TRANSFER_BUTTON": "Modo automático",
        "AUTO_TRANSFER_EXPLAIN": "Deseja tentar baixar artes hero e ícones para todos os portais que não possuem?<br>Após a transferência, elas serão aplicadas automaticamente.",
        "AUTO_TRANSFER_FINISHED": "Transferência automática finalizada",
        "AUTO_TRANSFER_GENERAL_ERROR": "Erro geral em {inv_name}: {error}",
        "AUTO_TRANSFER_NO_MISSING_ARTS": "Todos os portais já possuem arte hero e ícone",
        "BROWSE_BUTTON": "Procurar",
        "CHANGES_SAVED": "As alterações foram salvas.",
        "CHECK_UPDATE_BUTTON": "¿Atualização?",
        "CONFIRM_CLOSE_MESSAGE": "Deseja encerrar o portal atual e fechar o Meganimus?",
        "CONTENT": "Conteúdo",
        "CLOSE_MEGANIMUS": "Fechar Meganimus",
        "CREATE_PORTAL": "Criar portal",
        "CREATE_MULTIPLE_PORTALS": "Criar vários portais",
        "CUSTOM_COMMAND": "Comando customizável (Avançado)",
        "DEBUG_REAL_PORTAL_INITIATED": "[DEBUG] Portal iniciado como PID {pid}",
        "DEFAULT_QT_STYLE": "- Padrão do sistema -",
        "DELETE_PORTAL_CONFIRM_MESSAGE": "Tem certeza de que deseja remover o portal '{name}'?",
        "DELETE_PORTALS_CONFIRM_MESSAGE": "Tem certeza de que deseja remover os portais selecionados?",
        "DESELECT_ALL_IN_MULTIPLE_EDIT": "Nenhum",
        "DESKTOP_FOLDER": "Pasta área de trabalho",
        "DONE": "Concluído",
        "DO_NOT_CHANGE": "[Não mudar]",
        "DUPLICATE_NAME_IN_LIST": "Já existe outro portal na lista com o nome: {name}",
        "EDIT_MULTIPLE_PORTALS": "Editar vários portais",
        "ENTER_GAME_NAME": "Digite o nome de um jogo.",
        "ENVIRONMENT_VARS": "Variáveis",
        "ERROR": "Erro",
        "ERROR_CREATING_FILE": "Erro ao criar {file}: {error}",
        "ERROR_CREATING_SHORTCUTS_LOCATION": "Não foi possível usar essa localização:<br>{location}<br>Verifique sua existência e suas permissões",
        "ERROR_EXECUTOR_APPIMAGE_NOT_FOUND": "AppImage/Executável não encontrado em:<br>{path}",
        "ERROR_EXECUTOR_FLATPAK_NOT_FOUND": "O Flatpak '{name}' não foi encontrado no sistema.",
        "ERROR_EXECUTOR_SNAP_NOT_FOUND": "O Snap '{name}' não foi encontrado no sistema.",
        "ERROR_GAME_NOT_FOUND": "O jogo não foi encontrado em:<br>{path}",
        "ERROR_LOADING_FILE": "Erro ao carregar arquivo {file}: {error}",
        "ERROR_MOVING_SHORTCUTS": "Erro ao mover os arquivos .desktop {file}: {error}",
        "ERROR_REMOVING_FILE": "Erro ao remover {file}: {error}",
        "ERROR_TRANSFERRING_URL": "Erro ao transferir {url}: {error}",
        "EXECUTORS": "Executores configuráveis",
        "EXECUTOR_ARGS": "Argumentos",
        "EXECUTOR_COMMAND": "Comando",
        "EXECUTOR_COMMAND_NOT_SET": "Nenhum comando definido",
        "EXECUTOR_NOT_CONFIGURED": "Executor não configurado",
        "EXECUTOR_PATH_NOT_SET": "Nenhum caminho definido",
        "EXECUTOR_VERSION": "Versão",
        "EXECUTOR_VERSION_NOT_SELECTED": "Você precisa escolher uma versão primeiro.",
        "EXTRAS": "Extras",
        "EXTRACTING": "Extraindo: {name}",
        "GAME_PATH": "Jogo",
        "FAILED_UPDATE_TOML": "Não foi possível atualizar as informações do portal: {error}",
        "FILE": "Arquivo",
        "FOLDER": "Pasta",
        "FPS_DXVK_HUD": "DXVK HUD (Somente UMU)",
        "FPS_GALLIUM_HUD": "Gallium HUD (Nem sempre compatível)",
        "GAMEMODE": "Usar Feral gamemode",
        "ICON_TOOLBAR_SIZE": "Tamanho dos botões",
        "ICON_WIDTH_CLASSIC": "Tamanho do ícone (Clássico)",
        "ICON_WIDTH_GRID": "Tamanho do ícone (Grade)",
        "IMAGE_FILTER": "Arquivos de imagem (*.jpg *.jpeg *.png *.webp);;Todos os arquivos (*)",
        "ISO_ALREADY_MOUNTED": "ISO já está montada em {mount}",
        "ISO_MOUNT_DIR_REMOVED": "Diretório da ISO montada removido: {mount}",
        "ISO_MOUNT_DIR_REMOVE_FAILED": "Falha ao remover o diretório da ISO montada {mount}: {error}",
        "ISO_MOUNT_FAILED": "Falha ao montar a ISO {error}",
        "ISO_NOT_MOUNTED": "ISO não está montada em {mount}",
        "ISO_UNMOUNTED": "ISO desmontada com sucesso em {mount}",
        "ISO_UNMOUNT_EXCEPTION": "Ocorreu uma exceção ao desmontar a ISO: {error}",
        "ISO_UNMOUNT_FAILED": "Falha ao desmontar a ISO no diretório {mount}: {error}",
        "PORTAL": "Portal",
        "PORTAL_ALREADY_ACTIVE": "Encerrar portal atual e iniciar o selecionado?",
        "PORTAL_ALREADY_EXISTS": "Já existe um portal com esse nome. Escolha outro.",
        "PORTAL_ARGS": "Argumentos",
        "PORTAL_ART_PATH": "Arte",
        "PORTAL_GUI_PATH": "Ícone GUI",
        "PORTAL_INFO_ERROR": "Não foi possível acessar/executar o jogo ou encontrar informações sobre esse portal.",
        "PORTAL_INFO_LOADED": "Informações do portal carregadas com sucesso: {name}",
        "PORTAL_INFO_VIEWER_TITLE": "Informações dos portais",
        "PORTAL_LANGUAGE": "Idioma (Localidade)",
        "PORTAL_NAME": "Nome",
        "PORTAL_IN_MULTIPLE_CREATE_ALREADY_EXISTS": "O Portal '{name}' já existe, use outro nome.",
        "PORTAL_START_ERROR": "Ocorreu um erro ao tentar iniciar o portal: {error}",
        "PORTAL_STARTED": "Meganimus - Portal aberto: {portal_name}",
        "PS3_GAME_FOLDER_NOT_FOUND_IN_ISO": "Pasta PS3_GAME não encontrada na ISO",
        "LANGUAGE": "Idioma",
        "LANGUAGE_SET_ERROR": "[Erro] Falha ao definir LC_ALL: {error}",
        "LAYOUT_MODE": "Modo do layout",
        "LAYOUT_MODE_CLASSIC": "Clássico",
        "LAYOUT_MODE_GRID": "Grade",
        "LAYOUT_MODE_LIST": "Lista",
        "LOAD_HEROES": "Carregar heroes",
        "LOAD_ICONS": "Carregar ícones",
        "MANAGE_SHORTCUTS": "Gerenciar atalhos",
        "MANDATORY_FIELDS_ERROR": "Nome e jogo são obrigatórios.",
        "MARK_LISTED": "Marcar listados",
        "MEGANIMUS_CLOSED": "Meganimus fechado. Finalizando processos...",
        "MEGANIMUS_SETTINGS": "Preferências do Meganimus",
        "MEGANIMUS_TRAY_TOGGLE": "Alterar visibilidade",
        "MENU_FOLDER": "Pasta menu",
        "MODIFY_PORTAL": "Modificar portal",
        "MULTIPLE_PORTAL_EDITOR": "Editor de múltiplos portais",
        "MULTIPLE_PORTAL_CREATOR": "Criador de múltiplos portais",
        "MULTIPLE_PORTAL_REMOVER": "Removedor de múltiplos portais",
        "NAME": "Nome",
        "NAME_INVALID": "O nome é inválido, selecione outro.",
        "NAME_INVALID_IN_MULTIPLE": "O nome '{name}' é inválido, selecione outro.",
        "NEW_VERSION_AVAILABLE": "Nova versão encontrada: '{version}'.<br>Deseja ir para o repositório?",
        "NO_BUTTON": "Não",
        "NO_IMAGES": "Nenhuma imagem encontrada.",
        "NO_PORTAL_SELECTED_ERROR": "Nenhum portal selecionado.",
        "NO_PORTAL_SELECTED_MULTIPLE": "Nenhum portal selecionado",
        "NO_PORTALS_FOUND": "Nenhum portal foi encontrado.",
        "NO_PYQT6_FOUND_ERROR": "PyQt6 não encontrado.",
        "NO_RESULTS": "Nenhum resultado.",
        "NO_TAGS_FOUND": "Nenhuma tag encontrada no repositório.",
        "OWN_CATEGORY": "Categoria própria",
        "PLACEHOLDER_FOR_LANGUAGE": "- Sem idioma escolhido -",
        "QT_STYLE": "Estilo do QT",
        "RESET_BUTTON_MULTIPLE_EDIT": "Resetar",
        "REMOVE": "Remover",
        "REMOVE_MULTIPLE_PORTALS": "Remover vários portais",
        "REMOVE_SELECTED": "Remover selecionado",
        "EXECUTOR": "Executor",
        "RUNNING_COMMAND": "Executando comando: {command}",
        "RUNNING_IN_BACKGROUND": "Iniciado em segundo plano",
        "SAVE_BUTTON": "Salvar",
        "SEE_DATA": "Ver dados",
        "SEARCH": "Pesquisar",
        "SELECT": "Selecionar",
        "SELECT_ALL_IN_MULTIPLE_EDIT": "Todos",
        "SELECT_AT_LEAST_ONE_IMAGE": "Selecione pelo menos uma imagem.",
        "SELECT_FILE": "Selecionar arquivo",
        "SELECT_FOLDER": "Selecionar pasta",
        "SELECT_GAME": "Selecionar jogo",
        "SELECT_GAME_FOLDER": "Selecionar pasta do jogo",
        "SELECT_PORTAL_ART": "Selecionar arte",
        "SELECT_VERSION": "- Selecione uma versão -",
        "SETTINGS_SAVED_RESTART": "Alterações salvas.<br>Reinicie o Meganimus para aplicar as mudanças visuais.",
        "SGDB_API_KEY_LABEL": "Chave da API SteamGridDB",
        "SHORTCUTS_MANAGER_TITLE": "Gerenciador de atalhos",
        "SHORTCUTS_OF_DESKTOP": "Atalhos da área da trabalho",
        "SHORTCUTS_OF_MENU": "Atalhos do menu",
        "SHORTCUTS_PATHS": "Caminhos",
        "SHORTCUTS_SAVED": "Atalhos atualizados",
        "SHOW_FPS_OPTION": "Mostrar FPS",
        "SHOW_FPS_OPTION_HUD": "HUD selecionado",
        "START": "Iniciar",
        "START_PORTAL": "Iniciar portal",
        "START_RANDOM_PORTAL": "Portal aleatório",
        "STARTING_PORTAL": "Iniciando portal: {name}",
        "STOP_PORTAL": "Encerrar portal",
        "STOP_KILL_ERROR": "[Parar] Erro ao encerrar processo {pid}: {error}",
        "STOP_NO_PORTAL_ACTIVE": "[Parar] Nenhum portal ativo.",
        "STOP_NO_PROCESS_FOUND": "[Parar] Nenhum processo de portal encontrado para encerrar.",
        "STOP_PROCESS_SUCCESS": "[Parar] Processo {pid} encerrado com sucesso.",
        "TRANSFER": "Transferir",
        "TRANSFER_ARTS": "Artes",
        "TRANSFER_ARTS_TITLE": "Transferidor de artes do Steamgriddb",
        "TRANSFER_SUMMARY": "Transferido para:\n{dir}",
        "UNMARK_LISTED": "Desmarcar listados",
        "UPDATE_ERROR": "Erro ao verificar atualizações:\n{error}",
        "UPDATE_SHORTCUTS": "Atualizar atalhos",
        "USING_PYQT6": "Usando PyQt6",
        "YES_BUTTON": "Sim",
    }
}

# A Snap version of Meganimus isn't viable; it's only here to mimic the behavior of Zordeer.
if os.environ.get("SNAP"):
    meganimus_dir: Path = Path(os.environ["SNAP_REAL_HOME"]).joinpath("AppsFiles", "Meganimus")
else:
    meganimus_dir: Path = (Path.home() / "AppsFiles" / "Meganimus")
home_dir = meganimus_dir.parent.parent

# Loads translations from external TOML files.
def load_external_translations():
    external_translations = {}
    supported_languages = {"English USA": "en_US", "Português Brasil": "pt_BR"}

    # Translation folders
    translation_dirs = [
        Path(sys.argv[0]).parent / "translation",
        meganimus_dir / "translation",
        Path("/usr/share/Meganimus/translation")
    ]

    for translation_folder in translation_dirs:
        if translation_folder.exists():
            for toml_file in translation_folder.glob("meganimus-translation-*.toml"):
                try:
                    lang_code = toml_file.stem.replace("meganimus-translation-", "")
                    with open(toml_file, 'r', encoding='utf-8') as f:
                        lang_data = toml.load(f)

                    # Add to translations
                    external_translations[lang_code] = lang_data

                    # Adds to supported languages
                    lang_name = lang_data.get("language_name", lang_code)
                    supported_languages[lang_name] = lang_code

                    print(f"Loaded translation: {lang_name} ({lang_code})")

                except Exception as e:
                    print(f"Error loading translation {toml_file}: {e}")

    return external_translations, supported_languages

# Load external translations
EXTERNAL_TRANSLATIONS, SUPPORTED_LANGUAGES = load_external_translations()

# First, try the language configured in external translations.
def tr(key, **kwargs):
    # Get the translated string (from external or embedded translations)
    translated_string = None

    if LANG in EXTERNAL_TRANSLATIONS:
        translation_dict = EXTERNAL_TRANSLATIONS[LANG]
        translated_string = translation_dict.get(key)

    # Fallback to embedded translations if not found in external
    if not translated_string:
        translation_dict = BUILTIN_TRANSLATIONS.get(LANG, BUILTIN_TRANSLATIONS['en_US'])
        translated_string = translation_dict.get(key, BUILTIN_TRANSLATIONS['en_US'].get(key, key))

    # If we have a translated string, process special variables and formatting
    if translated_string:
        # Replace special variables
        translated_string = translated_string.replace("{__version__}", __version__)
        translated_string = translated_string.replace("{__creator__}", __creator__)

        # Apply formatting with any additional kwargs
        try:
            return translated_string.format(**kwargs)
        except KeyError:
            return translated_string

    # If no translation found, return the key itself
    return key

# PyQt6 Imports
try:
    from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QListWidget, QPushButton, QMessageBox, QToolBar, QDialog, QGridLayout,
    QLabel, QLineEdit, QHBoxLayout, QFileDialog, QComboBox, QCheckBox, QListWidgetItem, QStyleFactory, QProgressBar, QButtonGroup,
    QSplitter, QScrollArea, QRadioButton, QAbstractItemView, QFormLayout, QTreeWidget, QTreeWidgetItem, QSystemTrayIcon, QMenu, QListView, QSpinBox, QTextEdit)
    from PyQt6.QtCore import Qt, QThread, pyqtSignal, QSize, QTimer, QEvent, QTranslator, QLibraryInfo
    from PyQt6.QtGui import QAction, QIcon, QPixmap, QPainter, QPalette, QColor, QTextCharFormat, QTextCursor
    from PyQt6.QtNetwork import QLocalServer, QLocalSocket
    print(tr("USING_PYQT6"))
except ImportError:
    print(tr("NO_PYQT6_FOUND_ERROR"))
    sys.exit(1)

PORTAL_LOCALE_OPTIONS = [
    'English USA (en_US.UTF-8)',
    'Português Brasil (pt_BR.UTF-8)',
    'Português Portugal (pt_PT.UTF-8)',
    'Español España (es_ES.UTF-8)',
    'Español México (es_MX.UTF-8)',
    'Français (fr_FR.UTF-8)',
    'Deutsch (de_DE.UTF-8)',
    'Italiano (it_IT.UTF-8)',
    'Русский (ru_RU.UTF-8)',
    'Українська (uk_UA.UTF-8)',
    'Polski (pl_PL.UTF-8)',
    'Česky (cs_CZ.UTF-8)',
    'Slovenčina (sk_SK.UTF-8)',
    'Magyar (hu_HU.UTF-8)',
    'Română (ro_RO.UTF-8)',
    'Nederlands (nl_NL.UTF-8)',
    'Svenska (sv_SE.UTF-8)',
    'Norsk Bokmål (nb_NO.UTF-8)',
    'Dansk (da_DK.UTF-8)',
    'Suomi (fi_FI.UTF-8)',
    'Ελληνικά (el_GR.UTF-8)',
    'Български (bg_BG.UTF-8)',
    '日本語 (ja_JP.UTF-8)',
    '한국어 (ko_KR.UTF-8)',
    '简体中文 (zh_CN.UTF-8)',
    '繁體中文 (zh_TW.UTF-8)',
    'العربية (ar_SA.UTF-8)',
    'فارسی (fa_IR.UTF-8)',
    'Türkçe (tr_TR.UTF-8)',
    'हिन्दी (hi_IN.UTF-8)',
    'ไทย (th_TH.UTF-8)',
    'עברית (he_IL.UTF-8)',
]

# Meganimus settings (TOML)
# $HOME/AppsFiles/Meganimus/config/meganimus-settings.toml
meganimus_config_dir = meganimus_dir / "config"
meganimus_settings_file = meganimus_config_dir / "meganimus-settings.toml"

def detect_default_settings() -> dict:
    """Provides default settings for first-time creation."""
    return {
        "design": {
            "qt_style": "indefinite",
            "language": LANG if LANG else "en_US",
            "layout_mode": "classic",
            "icon_width_classic": 420,
            "icon_width_grid": 300,
            "toolbar_icon_size": 32,
            "toolbar_position": "top",
            "search_bar_visible": False,
            "executor_filter_index": 0,
            "toolbar_visible": True,
        },
        "window": {
            "isMaximized": "",
            "isFullScreen": "",
            "start_minimized": "",
            "windowSize": [780, 640],
        },
        "shortcut": {
            "desktop_dir": "",
            "menu_dir": "",
            "meganimus_command": "meganimus",
            "own_category": False,
            "menu_file": "",
            "directory_file": "",
        },
        "other": {
            "sgdb_apikey": "",
        },
        "executor": {
            "azaharplus_executor": "OFF",
            "azaharplus_command": "",
            "azaharplus_executor_args": "",
            "cemu_executor": "OFF",
            "cemu_command": "",
            "cemu_executor_args": "",
            "dolphin_executor": "OFF",
            "dolphin_command": "",
            "dolphin_executor_args": "",
            "duckstation_executor": "OFF",
            "duckstation_command": "",
            "duckstation_executor_args": "",
            "eden_executor": "OFF",
            "eden_command": "",
            "eden_executor_args": "",
            "flycast_executor": "OFF",
            "flycast_command": "",
            "flycast_executor_args": "",
            "melonds_executor": "OFF",
            "melonds_command": "",
            "melonds_executor_args": "",
            "mgba_executor": "OFF",
            "mgba_command": "",
            "mgba_executor_args": "",
            "pcsx2_executor": "OFF",
            "pcsx2_command": "",
            "pcsx2_executor_args": "",
            "ppsspp_executor": "OFF",
            "ppsspp_command": "",
            "ppsspp_executor_args": "",
            "rpcs3_executor": "OFF",
            "rpcs3_command": "",
            "rpcs3_executor_args": "",
            "ryubing_executor": "OFF",
            "ryubing_command": "",
            "ryubing_executor_args": "",
            "snes9x_executor": "OFF",
            "snes9x_command": "",
            "snes9x_executor_args": "",
            "umu_executor": "OFF",
            "umu_command": "",
            "umu_executor_args": "",
        }
    }

def load_settings() -> dict:
    """Loads settings, uses indefinite if saved style is unavailable."""
    defaults = detect_default_settings()

    try:
        with open(meganimus_settings_file, "r", encoding="utf-8") as f:
            data = toml.load(f)
    except Exception:
        # First creation: save default settings
        save_settings(defaults)
        return defaults

    # Remove outdated or unknown top-level keys
    for key in list(data.keys()):
        if key not in defaults:
            del data[key]

    # Ensure missing top-level sections exist
    for key, value in defaults.items():
        data.setdefault(key, value)

    # Ensure missing keys inside each section
    for section in defaults:
        for key, value in defaults[section].items():
            data[section].setdefault(key, value)

    # Remove outdated keys inside sections
    for section in defaults:
        for key in list(data[section].keys()):
            if key not in defaults[section]:
                del data[section][key]

    # Validate qt_style
    current_style = data["design"]["qt_style"]
    if current_style != "indefinite" and current_style not in QStyleFactory.keys():
        data["design"]["qt_style"] = "indefinite"
        save_settings(data)

    return data

def save_settings(data: dict) -> None:
    """Saves settings in TOML."""
    meganimus_config_dir.mkdir(parents=True, exist_ok=True)
    with open(meganimus_settings_file, "w", encoding="utf-8") as f:
        toml.dump(data, f)

class SettingsDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("MEGANIMUS_SETTINGS"))
        self.setMinimumSize(400, 340)

        self.settings = load_settings()
        layout = QVBoxLayout(self)
        top_layout = QFormLayout()

        # Qt Style
        style_label = QLabel(tr("QT_STYLE"))
        self.style_combo = QComboBox()
        self.style_combo.addItem(tr("DEFAULT_QT_STYLE"))
        self.style_combo.addItems(QStyleFactory.keys())
        saved_style = self.settings["design"].get("qt_style", "indefinite")
        if saved_style == "indefinite":
            self.style_combo.setCurrentText(tr("DEFAULT_QT_STYLE"))
        else:
            self.style_combo.setCurrentText(saved_style)
        top_layout.addRow(style_label, self.style_combo)

        # Language
        lang_label = QLabel(tr("LANGUAGE"))
        self.lang_combo = QComboBox()
        self.lang_combo.addItems(SUPPORTED_LANGUAGES.keys())
        saved_lang = self.settings["design"].get("language", LANG)
        lang_codes = list(SUPPORTED_LANGUAGES.values())
        if saved_lang in lang_codes:
            self.lang_combo.setCurrentIndex(lang_codes.index(saved_lang))
        else:
            self.lang_combo.setCurrentIndex(0)
        top_layout.addRow(lang_label, self.lang_combo)

        # View mode
        layout_mode_label = QLabel(tr("LAYOUT_MODE"))
        self.layout_mode_combo = QComboBox()
        self.layout_mode_combo.addItems([
            tr("LAYOUT_MODE_CLASSIC"),
            tr("LAYOUT_MODE_GRID"),
            tr("LAYOUT_MODE_LIST"),
        ])
        saved_layout_mode = self.settings["design"].get("layout_mode", "classic")
        index_map = {"classic": 0, "grid": 1, "list": 2}
        self.layout_mode_combo.setCurrentIndex(index_map.get(saved_layout_mode, 0))
        top_layout.addRow(layout_mode_label, self.layout_mode_combo)

        # Icon width classic
        classic_label = QLabel(tr("ICON_WIDTH_CLASSIC"))
        self.classic_width_input = QSpinBox()
        self.classic_width_input.setRange(50, 2000)
        self.classic_width_input.setValue(self.settings["design"].get("icon_width_classic", 420))
        top_layout.addRow(classic_label, self.classic_width_input)

        # Icon width grid
        grid_label = QLabel(tr("ICON_WIDTH_GRID"))
        self.grid_width_input = QSpinBox()
        self.grid_width_input.setRange(50, 2000)
        self.grid_width_input.setValue(self.settings["design"].get("icon_width_grid", 300))
        top_layout.addRow(grid_label, self.grid_width_input)

        # Toolbar icon size
        toolbar_icon_size_label = QLabel(tr("ICON_TOOLBAR_SIZE"))
        self.toolbar_icon_size_input = QSpinBox()
        self.toolbar_icon_size_input.setRange(16, 128)
        self.toolbar_icon_size_input.setValue(self.settings["design"].get("toolbar_icon_size", 32))
        top_layout.addRow(toolbar_icon_size_label, self.toolbar_icon_size_input)

        # SGDB API Key
        self.api_input = QLineEdit()
        self.api_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.api_input.setText(self.settings["other"].get("sgdb_apikey", ""))
        top_layout.addRow(tr("SGDB_API_KEY_LABEL"), self.api_input)

        layout.addLayout(top_layout)

        self.setLayout(layout)

        # Executors section
        executors_label = QLabel(tr("EXECUTORS"))
        self.executor_filter = QComboBox()
        executors = ["AzaharPlus", "Cemu", "Dolphin", "Duckstation", "Eden", "Flycast", "MelonDS", "mGBA", "PCSX2", "PPSSPP", "RPCS3", "Ryubing", "Snes9x", "UMU"]
        self.executor_filter.addItems(executors)

        top_layout.addRow(executors_label, self.executor_filter)

        self.executor_filter.currentIndexChanged.connect(self.show_selected_executor)

        self.executor_container = QVBoxLayout()
        layout.addLayout(self.executor_container)

        # Configuring executors and options
        self.executors_config = {
            "AzaharPlus": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    (tr("APPIMAGE_AND_EXECUTABLE"), "AppImage"),
                    (tr("CUSTOM_COMMAND"), "Custom"),
                ],
                "default_command": {
                    "Snap": "snap run azaharplus-emulator",
                    "Flatpak": "",
                },
                "default_args": {
                    "Snap": "-f",
                    "Flatpak": "-f",
                    "AppImage": "-f",
                    "Custom": ""
                }
            },
            "Cemu": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    (tr("APPIMAGE_AND_EXECUTABLE"), "AppImage"),
                    (tr("CUSTOM_COMMAND"), "Custom"),
                ],
                "default_command": {
                    "Snap": "snap run cemu-emulator",
                    "Flatpak": "flatpak run info.cemu.Cemu",
                },
                "default_args": {
                    "Snap": "-f -g",
                    "Flatpak": "-f -g",
                    "AppImage": "-f -g",
                    "Custom": ""
                }
            },
            "Dolphin": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    (tr("APPIMAGE_AND_EXECUTABLE"), "AppImage"),
                    (tr("CUSTOM_COMMAND"), "Custom"),
                ],
                "default_command": {
                    "Snap": "snap run dolphin-emulator-kyu",
                    "Flatpak": "flatpak run org.DolphinEmu.dolphin-emu",
                },
                "default_args": {
                    "Snap": "--batch -e",
                    "Flatpak": "--batch -e",
                    "AppImage": "--batch -e",
                    "Custom": ""
                }
            },
            "Duckstation": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    (tr("APPIMAGE_AND_EXECUTABLE"), "AppImage"),
                    (tr("CUSTOM_COMMAND"), "Custom"),
                ],
                "default_command": {
                    "Snap": "snap run duckstation-gpl",
                    "Flatpak": "flatpak run org.duckstation.DuckStation",
                },
                "default_args": {
                    "Snap": "-fullscreen",
                    "Flatpak": "-fullscreen",
                    "AppImage": "-fullscreen",
                    "Custom": ""
                }
            },
            "Eden": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    (tr("APPIMAGE_AND_EXECUTABLE"), "AppImage"),
                    (tr("CUSTOM_COMMAND"), "Custom"),
                ],
                "default_command": {
                    "Snap": "snap run eden-emulator",
                    "Flatpak": "",
                },
                "default_args": {
                    "Snap": "-f -g",
                    "Flatpak": "-f -g",
                    "AppImage": "-f -g",
                    "Custom": ""
                }
            },
            "Flycast": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    (tr("APPIMAGE_AND_EXECUTABLE"), "AppImage"),
                    (tr("CUSTOM_COMMAND"), "Custom"),
                ],
                "default_command": {
                    "Snap": "snap run flycast-emulator",
                    "Flatpak": "flatpak run org.flycast.Flycast",
                },
                "default_args": {
                    "Snap": "",
                    "Flatpak": "",
                    "AppImage": "",
                    "Custom": ""
                }
            },
            "MelonDS": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    (tr("APPIMAGE_AND_EXECUTABLE"), "AppImage"),
                    (tr("CUSTOM_COMMAND"), "Custom"),
                ],
                "default_command": {
                    "Snap": "snap run melonds-emulator",
                    "Flatpak": "flatpak run net.kuribo64.melonDS",
                },
                "default_args": {
                    "Snap": "-f",
                    "Flatpak": "-f",
                    "AppImage": "-f",
                    "Custom": ""
                }
            },
            "mGBA": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    (tr("APPIMAGE_AND_EXECUTABLE"), "AppImage"),
                    (tr("CUSTOM_COMMAND"), "Custom"),
                ],
                "default_command": {
                    "Snap": "snap run mgba-emulator",
                    "Flatpak": "flatpak run io.mgba.mGBA",
                },
                "default_args": {
                    "Snap": "-f",
                    "Flatpak": "-f",
                    "AppImage": "-f",
                    "Custom": ""
                }
            },
            "PCSX2": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    (tr("APPIMAGE_AND_EXECUTABLE"), "AppImage"),
                    (tr("CUSTOM_COMMAND"), "Custom"),
                ],
                "default_command": {
                    "Snap": "snap run pcsx2-emulator",
                    "Flatpak": "flatpak run net.pcsx2.PCSX2",
                },
                "default_args": {
                    "Snap": "-fullscreen",
                    "Flatpak": "-fullscreen",
                    "AppImage": "-fullscreen",
                    "Custom": ""
                }
            },
            "PPSSPP": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    (tr("APPIMAGE_AND_EXECUTABLE"), "AppImage"),
                    (tr("CUSTOM_COMMAND"), "Custom"),
                ],
                "default_command": {
                    "Snap": "snap run ppsspp-emulator",
                    "Flatpak": "flatpak run org.ppsspp.PPSSPP",
                },
                "default_args": {
                    "Snap": "--fullscreen --pause-menu-exit",
                    "Flatpak": "--fullscreen --pause-menu-exit",
                    "AppImage": "--fullscreen --pause-menu-exit",
                    "Custom": ""
                }
            },
            "RPCS3": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    (tr("APPIMAGE_AND_EXECUTABLE"), "AppImage"),
                    (tr("CUSTOM_COMMAND"), "Custom"),
                ],
                "default_command": {
                    "Snap": "snap run rpcs3-emulator",
                    "Flatpak": "flatpak run net.rpcs3.RPCS3",
                },
                "default_args": {
                    "Snap": "--no-gui --fullscreen",
                    "Flatpak": "--no-gui --fullscreen",
                    "AppImage": "--no-gui --fullscreen",
                    "Custom": ""
                }
            },
            "Ryubing": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    (tr("APPIMAGE_AND_EXECUTABLE"), "AppImage"),
                    (tr("CUSTOM_COMMAND"), "Custom"),
                ],
                "default_command": {
                    "Snap": "snap run ryubing-emulator",
                    "Flatpak": "flatpak run io.github.ryubing.Ryujinx",
                },
                "default_args": {
                    "Snap": "-f",
                    "Flatpak": "-f",
                    "AppImage": "-f",
                    "Custom": ""
                }
            },
            "Snes9x": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    (tr("APPIMAGE_AND_EXECUTABLE"), "AppImage"),
                    (tr("CUSTOM_COMMAND"), "Custom"),
                ],
                "default_command": {
                    "Snap": "snap run snes9x-gtk",
                    "Flatpak": "flatpak run com.snes9x.Snes9x",
                },
                "default_args": {
                    "Snap": "",
                    "Flatpak": "",
                    "AppImage": "",
                    "Custom": ""
                }
            },
            "UMU": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    (tr("APPIMAGE_AND_EXECUTABLE"), "AppImage"),
                    (tr("CUSTOM_COMMAND"), "Custom"),
                ],
                "default_command": {
                    "Snap": "snap run umu-run",
                    "Flatpak": "flatpak run org.openwinecomponents.umu.umu-launcher",
                },
                "default_args": {
                    "Snap": "",
                    "Flatpak": "",
                    "AppImage": "",
                    "Custom": ""
                }
            },
        }

        # Store widgets for each executor
        self.executor_widgets = {}

        for executor_name, config in self.executors_config.items():
            container_widget = QWidget()
            tab_layout = QVBoxLayout(container_widget)

            # Version
            version_layout = QHBoxLayout()
            version_label = QLabel(tr("EXECUTOR_VERSION"))
            combo = QComboBox()
            for text, value in config["options"]:
                combo.addItem(text, userData=value)
            version_layout.addWidget(version_label)
            version_layout.addWidget(combo, stretch=1)
            tab_layout.addLayout(version_layout)

            # Command + Executor arguments
            form_layout = QFormLayout()

            # Command
            command_label = QLabel(tr("EXECUTOR_COMMAND"))
            path_input = QLineEdit()
            form_layout.addRow(command_label, path_input)

            # Executor arguments
            args_label = QLabel(tr("EXECUTOR_ARGS"))
            args_input = QLineEdit()
            form_layout.addRow(args_label, args_input)

            tab_layout.addLayout(form_layout)

            # Buttons
            button_layout = QHBoxLayout()
            start_btn = QPushButton(tr("START"))
            browse_btn = QPushButton(tr("BROWSE_BUTTON"))
            button_layout.addWidget(start_btn)
            button_layout.addWidget(browse_btn)
            tab_layout.addLayout(button_layout)

            container_widget.setLayout(tab_layout)
            container_widget.setVisible(False)
            self.executor_container.addWidget(container_widget)

            # Save widgets for later access
            self.executor_widgets[executor_name] = {
                "widget": container_widget,
                "combo": combo,
                "path_input": path_input,
                "args_input": args_input,
                "start_btn": start_btn,
                "browse_btn": browse_btn
            }

            # Connects signals
            combo.currentIndexChanged.connect(
                partial(self._on_combo_changed, executor_name, combo))
            start_btn.clicked.connect(partial(self.start_executor_via_meganimus, executor_name))
            browse_btn.clicked.connect(partial(self.browse_executor, executor_name))

            # Initializes saved values
            saved_executor = self.settings["executor"].get(f"{executor_name.lower()}_executor", "OFF")
            saved_command = self.settings["executor"].get(f"{executor_name.lower()}_command", "")

            index = next((i for i in range(combo.count()) if combo.itemData(i) == saved_executor), 0)
            combo.setCurrentIndex(index)
            self.update_executor_command(executor_name, combo.itemData(index))

            widgets = self.executor_widgets[executor_name]
            default_args = self.executors_config[executor_name].get("default_args", {})
            saved_args = self.settings["executor"].get(f"{executor_name.lower()}_executor_args", "")

            if combo.itemData(index) in default_args and not saved_args:
                widgets["args_input"].setText(default_args[combo.itemData(index)])
            else:
                widgets["args_input"].setText(saved_args)

        self.show_selected_executor(self.executor_filter.currentIndex())

        # Save Button
        save_btn = QPushButton(tr("SAVE_BUTTON"))
        save_btn.clicked.connect(self.save_and_close)
        layout.addWidget(save_btn, alignment=Qt.AlignmentFlag.AlignRight)

    def _on_combo_changed(self, executor_name, combo, index):
        self.update_executor_command(executor_name, combo.itemData(index))

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def show_selected_executor(self, index):
        selected_executor = self.executor_filter.currentText()
        for name, widgets in self.executor_widgets.items():
            widgets["widget"].setVisible(name == selected_executor)

    def update_executor_command(self, executor_name, choice):
        widgets = self.executor_widgets[executor_name]
        path_input = widgets["path_input"]
        args_input = widgets["args_input"]
        browse_btn = widgets["browse_btn"]

        default_cmds = self.executors_config[executor_name].get("default_command", {})
        default_args = self.executors_config[executor_name].get("default_args", {})

        saved_executor_type = self.settings["executor"].get(f"{executor_name.lower()}_executor", "OFF")
        saved_command = self.settings["executor"].get(f"{executor_name.lower()}_command", "")
        saved_args = self.settings["executor"].get(f"{executor_name.lower()}_executor_args", "")

        # Command
        if choice == "AppImage":
            path_input.setText(saved_command if saved_executor_type == "AppImage" else "")
            path_input.setReadOnly(False)
            browse_btn.setEnabled(True)
        elif choice == "Custom":
            path_input.setText(saved_command if saved_executor_type == "Custom" else "")
            path_input.setReadOnly(False)
            browse_btn.setEnabled(True)
        elif choice in default_cmds:  # Snap / Flatpak
            path_input.setText(default_cmds[choice])
            path_input.setReadOnly(True)
            browse_btn.setEnabled(False)
        else:  # OFF / SELECT_VERSION
            path_input.setText("")
            path_input.setReadOnly(True)
            browse_btn.setEnabled(False)

        # Arguments
        if choice in ("Snap", "Flatpak", "AppImage"):
            args_input.setText(default_args.get(choice, ""))
            args_input.setReadOnly(True)
        elif choice == "Custom":
            args_input.setText(saved_args if saved_executor_type == "Custom" else "")
            args_input.setReadOnly(False)
        else:
            args_input.setText("")
            args_input.setReadOnly(True)

    def browse_executor(self, executor_name):
        widgets = self.executor_widgets[executor_name]
        path, _ = QFileDialog.getOpenFileName(self, tr("SELECT_FILE"))
        if path:
            widgets["path_input"].setText(path)

    def start_executor_via_meganimus(self, executor_name):
        widgets = self.executor_widgets[executor_name]
        executor_type = widgets["combo"].currentData()
        executor_command_str = widgets["path_input"].text().strip()

        if self.parent() and hasattr(self.parent(), "start_executor"):
            self.parent().start_executor(
                executor_name,
                executor_type=executor_type,
                executor_command_str=executor_command_str
            )

    def save_and_close(self):
        self.settings["design"]["qt_style"] = self.style_combo.currentText()
        selected_index = self.lang_combo.currentIndex()
        self.settings["design"]["language"] = list(SUPPORTED_LANGUAGES.values())[selected_index]
        self.settings["design"]["layout_mode"] = ["classic", "grid", "list"][self.layout_mode_combo.currentIndex()]
        self.settings["other"]["sgdb_apikey"] = self.api_input.text().strip()

        # Save the icon widths
        self.settings["design"]["icon_width_classic"] = self.classic_width_input.value()
        self.settings["design"]["icon_width_grid"] = self.grid_width_input.value()

        self.settings["design"]["toolbar_icon_size"] = self.toolbar_icon_size_input.value()

        # Save all executors dynamically
        for executor_name, widgets in self.executor_widgets.items():
            self.settings["executor"][f"{executor_name.lower()}_executor"] = widgets["combo"].currentData()
            self.settings["executor"][f"{executor_name.lower()}_command"] = widgets["path_input"].text()
            self.settings["executor"][f"{executor_name.lower()}_executor_args"] = widgets["args_input"].text()

        save_settings(self.settings)
        QMessageBox.information(
            self,
            tr("APP_NAME"),
            tr("SETTINGS_SAVED_RESTART")
        )
        self.accept()

class AddPortalDialog(QDialog):
    portal_saved = pyqtSignal()

    def __init__(self, parent=None, portal_data=None):
        super().__init__(parent)
        self.portal_data = portal_data

        if self.portal_data:
            self.setWindowTitle(tr("MODIFY_PORTAL"))
        else:
            self.setWindowTitle(tr("CREATE_PORTAL"))

        self.resize(600, 400)
        self.main_layout = QGridLayout(self)

        # Portal name
        self.name_label = QLabel(tr("PORTAL_NAME"))
        self.name_input = QLineEdit()
        self.main_layout.addWidget(self.name_label, 0, 0)
        self.main_layout.addWidget(self.name_input, 0, 1, 1, 2)

        # Executor option
        self.executor_label = QLabel(tr("EXECUTOR"))
        self.executor_combo = QComboBox()

        # List of executors
        executors = ["AzaharPlus", "Cemu", "Dolphin", "Duckstation", "Eden", "Flycast", "Linux", "MelonDS", "mGBA", "PCSX2", "PPSSPP", "RPCS3", "Ryubing", "Snes9x", "UMU"]
        for executor in executors:
            self.executor_combo.addItem(executor, userData=executor)

        # Add to layout (line 1, after PORTAL_NAME)
        self.main_layout.addWidget(self.executor_label, 1, 0)
        self.main_layout.addWidget(self.executor_combo, 1, 1, 1, 2)

        # "Game / Folder" line
        self.game_path_label = QLabel(tr("GAME_PATH"))
        self.game_path_input = QLineEdit()

        # Default button to select file
        self.game_file_button = QPushButton(tr("FILE"))
        self.game_file_button.clicked.connect(self.select_file)

        # Alternative button to select folder
        self.game_folder_button = QPushButton(tr("FOLDER"))
        self.game_folder_button.clicked.connect(self.select_folder)

        # Horizontal layout with two buttons
        game_buttons_widget = QWidget()
        game_buttons_layout = QHBoxLayout(game_buttons_widget)
        game_buttons_layout.setContentsMargins(0, 0, 0, 0)
        game_buttons_layout.setSpacing(6)
        game_buttons_layout.addWidget(self.game_file_button)
        game_buttons_layout.addWidget(self.game_folder_button)

        # Add everything to the grid
        self.main_layout.addWidget(self.game_path_label, 2, 0)
        self.main_layout.addWidget(self.game_path_input, 2, 1)
        self.main_layout.addWidget(game_buttons_widget, 2, 2)

        # Portal art
        self.portal_art_label = QLabel(tr("PORTAL_ART_PATH"))
        self.portal_art_input = QLineEdit()
        self.portal_art_button = QPushButton(tr("BROWSE_BUTTON"))
        self.portal_art_button.clicked.connect(self.select_portal_art)
        self.main_layout.addWidget(self.portal_art_label, 3, 0)
        self.main_layout.addWidget(self.portal_art_input, 3, 1)
        self.main_layout.addWidget(self.portal_art_button, 3, 2)

        # Portal gui icon
        self.portal_gui_label = QLabel(tr("PORTAL_GUI_PATH"))
        self.portal_gui_input = QLineEdit()
        self.portal_gui_button = QPushButton(tr("BROWSE_BUTTON"))
        self.portal_gui_button.clicked.connect(self.select_portal_gui)
        self.main_layout.addWidget(self.portal_gui_label, 4, 0)
        self.main_layout.addWidget(self.portal_gui_input, 4, 1)
        self.main_layout.addWidget(self.portal_gui_button, 4, 2)

        # Language/location
        self.language_label = QLabel(tr("PORTAL_LANGUAGE"))
        self.language_input = QComboBox()
        self.language_input.addItems([tr("PLACEHOLDER_FOR_LANGUAGE")] + PORTAL_LOCALE_OPTIONS)
        self.main_layout.addWidget(self.language_label, 5, 0)
        self.main_layout.addWidget(self.language_input, 5, 1, 1, 2)

        # Gamemode
        self.gamemode_checkbox = QCheckBox(tr("GAMEMODE"))
        self.gamemode_checkbox.setChecked(True)
        self.main_layout.addWidget(self.gamemode_checkbox, 6, 0, 1, 3)

        # FPS HUD
        self.fps_layout = QHBoxLayout()
        self.show_fps_checkbox = QCheckBox(tr("SHOW_FPS_OPTION"))
        self.show_fps_checkbox.setChecked(False)
        self.fps_hud_combo = QComboBox()
        self.fps_hud_options = [("FPS_GALLIUM_HUD", tr("FPS_GALLIUM_HUD")), ("FPS_DXVK_HUD", tr("FPS_DXVK_HUD"))]
        for id, text in self.fps_hud_options:
            self.fps_hud_combo.addItem(text, id)
        self.fps_hud_combo.setEnabled(False)

        self.show_fps_checkbox.stateChanged.connect(self.update_fps_hud_state)
        self.fps_layout.addWidget(self.show_fps_checkbox)
        self.fps_layout.addWidget(self.fps_hud_combo)
        self.main_layout.addLayout(self.fps_layout, 7, 0, 1, 3)

        # Environment variables
        self.env_vars_label = QLabel(tr("ENVIRONMENT_VARS"))
        self.env_vars_input = QLineEdit()
        self.main_layout.addWidget(self.env_vars_label, 8, 0)
        self.main_layout.addWidget(self.env_vars_input, 8, 1, 1, 2)

        # Arguments
        self.portal_args_label = QLabel(tr("PORTAL_ARGS"))
        self.portal_args_input = QLineEdit()
        self.main_layout.addWidget(self.portal_args_label, 9, 0)
        self.main_layout.addWidget(self.portal_args_input, 9, 1, 1, 2)

        # Buttons
        self.buttons_layout = QHBoxLayout()
        self.remove_portal_button = QPushButton(tr("REMOVE"))
        self.save_button = QPushButton(tr("SAVE_BUTTON"))
        self.save_button.clicked.connect(self.save_and_accept)

        if self.portal_data:
            self.buttons_layout.addWidget(self.remove_portal_button)
            self.remove_portal_button.clicked.connect(self.delete_portal)

        self.buttons_layout.addStretch()
        self.buttons_layout.addWidget(self.save_button)
        self.main_layout.addLayout(self.buttons_layout, 11, 0, 1, 3)

        if self.portal_data:
            self.load_portal_data()

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def update_fps_hud_state(self, state=None):
        self.fps_hud_combo.setEnabled(self.show_fps_checkbox.isChecked())

    def load_portal_data(self):
        self.name_input.setText(self.portal_data.get('name', ''))
        self.game_path_input.setText(self.portal_data.get('game_path', ''))
        self.portal_art_input.setText(self.portal_data.get('art_path', ''))
        self.portal_gui_input.setText(self.portal_data.get('gui_path', ''))

        # Executor saved
        saved_executor = self.portal_data.get('executor', 'Linux')
        index_executor = self.executor_combo.findData(saved_executor)
        if index_executor != -1:
            self.executor_combo.setCurrentIndex(index_executor)

        env_vars_text = self.portal_data.get('env_vars', '').strip()
        self.env_vars_input.setText(env_vars_text)

        self.portal_args_input.setText(self.portal_data.get('portal_args', ''))

        language = self.portal_data.get('language', '')
        index_lang = self.language_input.findText(language)
        if index_lang != -1:
            self.language_input.setCurrentIndex(index_lang)

        use_gamemode = self.portal_data.get('use_gamemode', True)
        self.gamemode_checkbox.setChecked(use_gamemode)

        show_fps = self.portal_data.get('show_fps', False)
        self.show_fps_checkbox.setChecked(show_fps)
        self.update_fps_hud_state()

        fps_hud_type = self.portal_data.get('fps_hud_type', '')
        index_hud = self.fps_hud_combo.findData(fps_hud_type)
        if index_hud != -1:
            self.fps_hud_combo.setCurrentIndex(index_hud)

    def select_file(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_GAME"),
            "",
            "",
        )
        if file_path:
            self.game_path_input.setText(file_path)

    def select_folder(self):
        folder_path = QFileDialog.getExistingDirectory(
            self,
            tr("SELECT_GAME_FOLDER"),
            "",
        )
        if folder_path:
            self.game_path_input.setText(folder_path)

    def select_portal_art(self):
        heroes_dir = Path(self.parent().meganimus_dir) / "sgdb" / "heroes"
        heroes_dir.mkdir(parents=True, exist_ok=True)
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_PORTAL_ART"),
            str(heroes_dir),
            tr("IMAGE_FILTER")
        )
        if file_path:
            self.portal_art_input.setText(file_path)

    def select_portal_gui(self):
        icons_dir = Path(self.parent().meganimus_dir) / "sgdb" / "icons"
        icons_dir.mkdir(parents=True, exist_ok=True)
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_PORTAL_GUI"),
            str(icons_dir),
            tr("IMAGE_FILTER")
        )
        if file_path:
            self.portal_gui_input.setText(file_path)

    def get_form_data(self):
        env_vars_text = self.env_vars_input.text().strip()
        selected_lang = self.language_input.currentText()
        if selected_lang == tr("PLACEHOLDER_FOR_LANGUAGE"):
            selected_lang = ""

        fps_hud_type = self.fps_hud_combo.currentData()

        art_path = self.portal_art_input.text().strip()
        gui_path = self.portal_gui_input.text().strip()

        return {
            "name": self.name_input.text(),
            "executor": self.executor_combo.currentData(),
            "game_path": self.game_path_input.text(),
            "art_path": art_path,
            "gui_path": gui_path,
            "language": selected_lang,
            "use_gamemode": self.gamemode_checkbox.isChecked(),
            "show_fps": self.show_fps_checkbox.isChecked(),
            "fps_hud_type": fps_hud_type,
            "env_vars": env_vars_text,
            "portal_args": self.portal_args_input.text(),
        }

    def save_and_accept(self):
        portal_data = self.get_form_data()
        if portal_data["name"] and portal_data["game_path"]:
            art_dir = meganimus_dir / "art"
            gui_dir = meganimus_dir / "art" / "gui"
            art_dir.mkdir(parents=True, exist_ok=True)
            gui_dir.mkdir(parents=True, exist_ok=True)

            safe_portal_name = portal_data["name"].replace(" ", "_").lower()
            portal_file = meganimus_config_dir / f"portal-info-{safe_portal_name}.toml"

            # Check for duplicate portal name
            if portal_file.exists() and (not self.portal_data or self.portal_data.get("name", "").lower() != portal_data["name"].lower()):
                QMessageBox.warning(self, tr("APP_NAME"), tr("PORTAL_ALREADY_EXISTS"))
                return

            # art_path
            if portal_data.get("art_path"):
                art_path = Path(portal_data["art_path"])
                if art_path.exists() and art_path.is_file():
                    # Remove old images with old name only if we're selecting a NEW file
                    if self.portal_data and self.portal_data.get("art_path"):
                        old_art_path = Path(self.portal_data['art_path'])
                        # Only remove if the new file is different from the old one
                        if old_art_path != art_path:
                            old_safe_name = self.portal_data.get('name', '').replace(" ", "_").lower()
                            for old_file in art_dir.glob(f"{old_safe_name}.*"):
                                try:
                                    old_file.unlink()
                                except Exception:
                                    pass

                    # Copy new image only if it's not already in the art_dir
                    if art_path.parent != art_dir:
                        art_extension = art_path.suffix.lower()
                        new_art_path = art_dir / f"{safe_portal_name}{art_extension}"
                        try:
                            shutil.copyfile(art_path, new_art_path)
                            portal_data["art_path"] = str(new_art_path)
                        except Exception:
                            portal_data["art_path"] = ""
                    else:
                        # File is already in art_dir, just update the path with new name if needed
                        if self.portal_data:
                            old_safe_name = self.portal_data.get('name', '').replace(" ", "_").lower()
                            if old_safe_name != safe_portal_name:
                                new_art_path = art_dir / f"{safe_portal_name}{art_path.suffix.lower()}"
                                try:
                                    art_path.rename(new_art_path)
                                    portal_data["art_path"] = str(new_art_path)
                                except Exception:
                                    portal_data["art_path"] = str(art_path)
            elif self.portal_data and self.portal_data.get("art_path"):
                # User removed the art path - delete old file
                old_art_path = Path(self.portal_data['art_path'])
                if old_art_path.exists() and old_art_path.is_file() and old_art_path.parent == art_dir:
                    try:
                        old_art_path.unlink()
                    except Exception:
                        pass
                portal_data["art_path"] = ""

            # gui_path
            if portal_data.get("gui_path"):
                gui_path = Path(portal_data["gui_path"])
                if gui_path.exists() and gui_path.is_file():
                    # Remove old images with old name only if we're selecting a NEW file
                    if self.portal_data and self.portal_data.get("gui_path"):
                        old_gui_path = Path(self.portal_data['gui_path'])
                        # Only remove if the new file is different from the old one
                        if old_gui_path != gui_path:
                            old_safe_name = self.portal_data.get('name', '').replace(" ", "_").lower()
                            for old_file in gui_dir.glob(f"{old_safe_name}.*"):
                                try:
                                    old_file.unlink()
                                except Exception:
                                    pass

                    # Copy new image only if it's not already in the gui_dir
                    if gui_path.parent != gui_dir:
                        gui_extension = gui_path.suffix.lower()
                        new_gui_path = gui_dir / f"{safe_portal_name}{gui_extension}"
                        try:
                            shutil.copyfile(gui_path, new_gui_path)
                            portal_data["gui_path"] = str(new_gui_path)
                        except Exception:
                            portal_data["gui_path"] = ""
                    else:
                        # File is already in gui_dir, just update the path with new name if needed
                        if self.portal_data:
                            old_safe_name = self.portal_data.get('name', '').replace(" ", "_").lower()
                            if old_safe_name != safe_portal_name:
                                new_gui_path = gui_dir / f"{safe_portal_name}{gui_path.suffix.lower()}"
                                try:
                                    gui_path.rename(new_gui_path)
                                    portal_data["gui_path"] = str(new_gui_path)
                                except Exception:
                                    portal_data["gui_path"] = str(gui_path)
            elif self.portal_data and self.portal_data.get("gui_path"):
                # User removed the gui path - delete old file
                old_gui_path = Path(self.portal_data['gui_path'])
                if old_gui_path.exists() and old_gui_path.is_file() and old_gui_path.parent == gui_dir:
                    try:
                        old_gui_path.unlink()
                    except Exception:
                        pass
                portal_data["gui_path"] = ""

            # Save TOML
            try:
                with open(portal_file, 'w', encoding="utf-8") as f:
                    toml.dump(portal_data, f)
            except Exception as e:
                QMessageBox.critical(self, tr("APP_NAME"), tr("NAME_INVALID", error=str(e)))
                return

            # Remove old TOML if name changed
            if self.portal_data:
                old_safe_portal_name = self.portal_data.get('name', '').replace(" ", "_").lower()
                new_safe_portal_name = portal_data['name'].replace(" ", "_").lower()
                if old_safe_portal_name != new_safe_portal_name:
                    old_portal_file_path = meganimus_config_dir / f"portal-info-{old_safe_portal_name}.toml"
                    if old_portal_file_path.exists():
                        old_portal_file_path.unlink()

            self.portal_saved.emit()
            self.accept()
        else:
            QMessageBox.warning(self, tr("CREATE_PORTAL"), tr("MANDATORY_FIELDS_ERROR"))

    def delete_portal(self):
        portal_name = self.name_input.text().strip()
        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle(tr("REMOVE"))
        msg.setText(tr("DELETE_PORTAL_CONFIRM_MESSAGE", name=portal_name))
        msg.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg.button(QMessageBox.StandardButton.Yes).setText(tr("YES_BUTTON"))
        msg.button(QMessageBox.StandardButton.No).setText(tr("NO_BUTTON"))

        if msg.exec() != QMessageBox.StandardButton.Yes:
            return

        safe_portal_name = portal_name.replace(" ", "_").lower()
        portal_file = meganimus_config_dir / f"portal-info-{safe_portal_name}.toml"

        if not portal_file.exists():
            QMessageBox.critical(self, tr("APP_NAME"), tr("PORTAL_INFO_ERROR"))
            return

        # Load portal data before removing
        with open(portal_file, encoding='utf-8') as f:
            portal_data = toml.load(f)

        # Remove the configuration file
        portal_file.unlink()

        # Remove artwork if it exists
        art = portal_data.get('art_path')
        if art:
            art_path = Path(art)
            if art_path.exists() and art_path.is_file():
                try:
                    art_path.unlink()
                except Exception:
                    pass

        # Remove gui icon if it exists
        gui = portal_data.get('gui_path')
        if gui:
            gui_path = Path(gui)
            if gui_path.exists() and gui_path.is_file():
                try:
                    gui_path.unlink()
                except Exception:
                    pass

        self.parent().load_portals()
        self.accept()

class MultipleCreatePortalsDialog(QDialog):
    portals_saved = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("MULTIPLE_PORTAL_CREATOR"))
        self.resize(700, 500)

        self.main_layout = QVBoxLayout(self)

        # Executor and Language layout (grid)
        top_grid = QGridLayout()

        # Executor and combobox
        executor_label = QLabel(tr("EXECUTOR"))
        self.executor_combo = QComboBox()
        executors = ["AzaharPlus", "Cemu", "Dolphin", "Duckstation", "Eden", "Flycast", "Linux", "MelonDS", "mGBA", "PCSX2", "PPSSPP", "RPCS3", "Ryubing", "Snes9x", "UMU"]
        for executor in executors:
            self.executor_combo.addItem(executor, userData=executor)
        top_grid.addWidget(executor_label, 0, 0)
        top_grid.addWidget(self.executor_combo, 0, 1)

        # Language and combobox
        language_label = QLabel(tr("PORTAL_LANGUAGE"))
        self.language_input = QComboBox()
        self.language_input.addItems([tr("PLACEHOLDER_FOR_LANGUAGE")] + PORTAL_LOCALE_OPTIONS)
        top_grid.addWidget(language_label, 1, 0)
        top_grid.addWidget(self.language_input, 1, 1)

        self.main_layout.addLayout(top_grid)

        # TreeWidget for multiple portals
        self.file_list = QTreeWidget()
        self.file_list.setColumnCount(1)
        self.file_list.setHeaderHidden(True)
        self.file_list.setExpandsOnDoubleClick(True)
        self.main_layout.addWidget(self.file_list)

        # Add/Remove File Buttons
        btn_layout = QHBoxLayout()
        self.add_files_button = QPushButton(tr("ADD_FILES"))
        self.add_files_button.clicked.connect(self.add_files)
        self.add_folder_button = QPushButton(tr("ADD_FOLDER"))
        self.add_folder_button.clicked.connect(self.add_folders)
        self.remove_item_button = QPushButton(tr("REMOVE_SELECTED"))
        self.remove_item_button.clicked.connect(self.remove_selected_item)
        btn_layout.addWidget(self.add_files_button)
        btn_layout.addWidget(self.add_folder_button)
        btn_layout.addWidget(self.remove_item_button)
        self.main_layout.addLayout(btn_layout)

        # Save button
        save_layout = QHBoxLayout()
        self.save_button = QPushButton(tr("SAVE_BUTTON"))
        self.save_button.clicked.connect(self.save_multiple)
        save_layout.addStretch()
        save_layout.addWidget(self.save_button)
        self.main_layout.addLayout(save_layout)

        self.paths = []

    # Utility functions

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def add_files(self):
        files, _ = QFileDialog.getOpenFileNames(self, tr("SELECT_GAME"), "", "")
        for f in files:
            self.add_file_item(f)

    def add_folders(self):
        folder = QFileDialog.getExistingDirectory(self, tr("SELECT_GAME_FOLDER"), "")
        if folder:
            self.add_file_item(folder)

    def remove_selected_item(self):
        selected = self.file_list.currentItem()
        if selected and hasattr(selected, "path"):
            index = self.file_list.indexOfTopLevelItem(selected)
            self.file_list.takeTopLevelItem(index)
            self.paths.remove(selected.path)

    def add_file_item(self, path):
        if path in self.paths:
            return
        self.paths.append(path)

        # Internal widget for options
        item_widget = QWidget()
        layout = QVBoxLayout(item_widget)
        layout.setContentsMargins(2, 2, 2, 2)
        layout.setSpacing(4)

        # Portal name
        name_layout = QHBoxLayout()
        name_label = QLabel(tr("PORTAL_NAME"))
        name_input = QLineEdit(Path(path).stem)
        name_layout.addWidget(name_label)
        name_layout.addWidget(name_input)
        layout.addLayout(name_layout)

        # Checkboxes
        gamemode_cb = QCheckBox(tr("GAMEMODE"))
        gamemode_cb.setChecked(True)
        layout.addWidget(gamemode_cb)

        # FPS HUD
        fps_layout = QHBoxLayout()
        show_fps_cb = QCheckBox(tr("SHOW_FPS_OPTION"))
        fps_hud_combo = QComboBox()
        fps_hud_options = [
            ("FPS_GALLIUM_HUD", tr("FPS_GALLIUM_HUD")),
            ("FPS_DXVK_HUD", tr("FPS_DXVK_HUD"))
        ]
        for id, text in fps_hud_options:
            fps_hud_combo.addItem(text, id)
        fps_hud_combo.setEnabled(False)
        show_fps_cb.stateChanged.connect(partial(fps_hud_combo.setEnabled))
        fps_layout.addWidget(show_fps_cb)
        fps_layout.addWidget(fps_hud_combo)
        layout.addLayout(fps_layout)

        # QTreeWidgetItem with child containing widget
        parent_item = QTreeWidgetItem(self.file_list)
        parent_item.setText(0, Path(path).name)
        child_item = QTreeWidgetItem(parent_item)
        child_item.setFlags(child_item.flags() & ~Qt.ItemFlag.ItemIsSelectable)
        self.file_list.setItemWidget(child_item, 0, item_widget)
        parent_item.setExpanded(True)

        # Save references
        parent_item.path = path
        parent_item.name_input = name_input
        parent_item.gamemode_cb = gamemode_cb
        parent_item.show_fps_cb = show_fps_cb
        parent_item.fps_hud_combo = fps_hud_combo

    def save_multiple(self):
        # Executor and item validation
        executor = self.executor_combo.currentText()
        if self.file_list.topLevelItemCount() == 0:
            QMessageBox.warning(self, tr("CREATE_PORTAL"), tr("MANDATORY_FIELDS_ERROR"))
            return

        art_dir = meganimus_dir / "art"
        gui_dir = meganimus_dir / "art"/ "gui"
        art_dir.mkdir(parents=True, exist_ok=True)
        gui_dir.mkdir(parents=True, exist_ok=True)

        # Name and duplicate validation
        existing_names = set()
        for i in range(self.file_list.topLevelItemCount()):
            item = self.file_list.topLevelItem(i)
            name = item.name_input.text().strip()

            # Empty name
            if not name:
                QMessageBox.warning(self, tr("APP_NAME"), tr("MANDATORY_FIELDS_ERROR"))
                return

            safe_portal_name = name.replace(" ", "_").lower()

            # Duplicate in own list
            if safe_portal_name in existing_names:
                QMessageBox.warning(
                    self,
                    tr("APP_NAME"),
                    tr("DUPLICATE_NAME_IN_LIST", name=name)
                )
                return
            existing_names.add(safe_portal_name)

            # Duplicate in filesystem
            test_path = meganimus_config_dir / f"portal-info-{safe_portal_name}.toml"
            if test_path.exists():
                QMessageBox.warning(
                    self,
                    tr("APP_NAME"),
                    tr("PORTAL_IN_MULTIPLE_CREATE_ALREADY_EXISTS", name=name)
                )
                return

            # Test if you can write the file
            try:
                with open(test_path, 'w', encoding="utf-8") as f:
                    toml.dump({}, f)
                test_path.unlink()
            except Exception as e:
                QMessageBox.critical(
                    self,
                    tr("APP_NAME"),
                    tr("NAME_INVALID_IN_MULTIPLE", name=name, error=str(e))
                )
                return

        selected_lang = self.language_input.currentText()
        if selected_lang == tr("PLACEHOLDER_FOR_LANGUAGE"):
            selected_lang = ""

        for i in range(self.file_list.topLevelItemCount()):
            item = self.file_list.topLevelItem(i)
            name = item.name_input.text().strip()
            safe_portal_name = name.replace(" ", "_").lower()
            file_path = meganimus_config_dir / f"portal-info-{safe_portal_name}.toml"

            # Save TOML
            try:
                with open(file_path, 'w', encoding="utf-8") as f:
                    toml.dump({
                        "name": name,
                        "executor": executor,
                        "game_path": item.path,
                        "art_path": "",
                        "gui_path": "",
                        "language": selected_lang,
                        "use_gamemode": item.gamemode_cb.isChecked(),
                        "show_fps": item.show_fps_cb.isChecked(),
                        "fps_hud_type": item.fps_hud_combo.currentData() or "",
                        "env_vars": "",
                        "portal_args": ""
                    }, f)
            except Exception as e:
                QMessageBox.critical(self, tr("APP_NAME"), tr("FAILED_UPDATE_TOML", error=str(e)))
                return

        self.portals_saved.emit()
        self.accept()

    def save_portal_data(self, data):
        safe_portal_name = data["name"].replace(" ", "_").lower()
        file_path = meganimus_config_dir / f"portal-info-{safe_portal_name}.toml"
        if file_path.exists():
            return
        with open(file_path, 'w', encoding="utf-8") as f:
            toml.dump(data, f)

class MultipleRemovePortalDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("MULTIPLE_PORTAL_REMOVER"))
        self.resize(340, 400)
        self.parent_ref = parent

        main_layout = QVBoxLayout(self)

        # Search bar
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText(tr("SEARCH"))
        self.search_input.textChanged.connect(self.update_portal_list)
        main_layout.addWidget(self.search_input)

        # Executor filter combobox
        self.executor_filter = QComboBox()
        self.executor_filter.currentIndexChanged.connect(self.update_portal_list)
        main_layout.addWidget(self.executor_filter)

        # Scroll area for checkboxes
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)
        self.scroll_layout.setContentsMargins(6, 6, 6, 6)
        self.scroll_layout.setSpacing(4)
        self.scroll_content.setLayout(self.scroll_layout)
        self.scroll_area.setWidget(self.scroll_content)
        main_layout.addWidget(self.scroll_area)

        # Buttons Select All / Deselect All
        btn_layout = QHBoxLayout()
        self.select_all_btn = QPushButton(tr("SELECT_ALL_IN_MULTIPLE_EDIT"))
        self.deselect_all_btn = QPushButton(tr("DESELECT_ALL_IN_MULTIPLE_EDIT"))
        self.select_all_btn.clicked.connect(self.select_all_portals)
        self.deselect_all_btn.clicked.connect(self.deselect_all_portals)
        btn_layout.addWidget(self.select_all_btn)
        btn_layout.addWidget(self.deselect_all_btn)
        main_layout.addLayout(btn_layout)

        # Remove button
        self.remove_button = QPushButton(tr("REMOVE"))
        self.remove_button.clicked.connect(self.remove_selected_portals)
        main_layout.addWidget(self.remove_button)

        # Dictionary portal_name -> checkbox
        self.portal_checkboxes = {}
        self.load_portals()

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def load_portals(self):
        """It loads all the portals and creates the checkboxes."""
        self.portal_checkboxes.clear()
        while self.scroll_layout.count():
            item = self.scroll_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

        portal_files = sorted(meganimus_config_dir.glob("portal-info-*.toml"))
        
        # Executors used
        used_executors = set()
        
        for portal_file in portal_files:
            try:
                with open(portal_file, encoding="utf-8") as f:
                    data = toml.load(f)
                name = data.get("name", portal_file.stem)
                cb = QCheckBox(name)
                cb.portal_file = portal_file
                executor = data.get("executor", "Linux")
                cb.executor = executor
                cb.art_path = data.get("art_path")
                cb.gui_path = data.get("gui_path")
                self.scroll_layout.addWidget(cb)
                self.portal_checkboxes[name] = cb
                
                # Adds used executors to the list.
                used_executors.add(executor)
                
            except Exception:
                continue
        self.scroll_layout.addStretch()
        
        # Add the used executors to the combobox.
        self.executor_filter.clear()
        self.executor_filter.addItem(tr("ALL_PORTALS"))
        
        # Add executors in alphabetical order.
        for executor in sorted(used_executors):
            self.executor_filter.addItem(executor)

    def update_portal_list(self):
        """Filter the portals by the selected text and executor."""
        text = self.search_input.text().lower()
        selected_executor = self.executor_filter.currentText()

        for name, cb in self.portal_checkboxes.items():
            executor = getattr(cb, "executor", "Linux")
            matches_text = text in name.lower()
            matches_executor = (selected_executor == tr("ALL_PORTALS")) or (executor == selected_executor)
            cb.setVisible(matches_text and matches_executor)

    def select_all_portals(self):
        for cb in self.portal_checkboxes.values():
            if cb.isVisible():
                cb.setChecked(True)

    def deselect_all_portals(self):
        for cb in self.portal_checkboxes.values():
            if cb.isVisible():
                cb.setChecked(False)

    def remove_selected_portals(self):
        to_remove = [cb for cb in self.portal_checkboxes.values() if cb.isChecked()]
        if not to_remove:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_PORTAL_SELECTED_MULTIPLE"))
            return

        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle(tr("MULTIPLE_PORTAL_REMOVER"))
        msg.setText(tr("DELETE_PORTALS_CONFIRM_MESSAGE"))
        msg.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg.button(QMessageBox.StandardButton.Yes).setText(tr("YES_BUTTON"))
        msg.button(QMessageBox.StandardButton.No).setText(tr("NO_BUTTON"))

        if msg.exec() != QMessageBox.StandardButton.Yes:
            return

        for cb in to_remove:
            # Remove TOML
            try:
                if cb.portal_file.exists():
                    cb.portal_file.unlink()
            except Exception:
                pass

            # Remove art
            if cb.art_path:
                art_path = Path(cb.art_path)
                if art_path.exists() and art_path.is_file():
                    try:
                        art_path.unlink()
                    except Exception:
                        pass

            # Remove gui icon
            if cb.gui_path:
                gui_path = Path(cb.gui_path)
                if gui_path.exists() and gui_path.is_file():
                    try:
                        gui_path.unlink()
                    except Exception:
                        pass

        self.load_portals()
        if self.parent_ref:
            self.parent_ref.load_portals()

        self.accept()

class MultipleEditPortalDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("MULTIPLE_PORTAL_EDITOR"))
        self.resize(500, 480)
        self.parent_ref = parent

        # Main layout
        splitter = QSplitter(Qt.Orientation.Horizontal, self)
        splitter.setChildrenCollapsible(False)

        # Left: selection of portals
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)

        # Search bar
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText(tr("SEARCH"))
        self.search_input.textChanged.connect(self.update_portal_list)
        left_layout.addWidget(self.search_input)

        # Executor filter combobox
        self.executor_filter = QComboBox()
        self.executor_filter.currentIndexChanged.connect(self.update_portal_list)
        left_layout.addWidget(self.executor_filter)

        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)
        self.scroll_layout.setContentsMargins(6, 6, 6, 6)
        self.scroll_layout.setSpacing(4)
        self.scroll_content.setLayout(self.scroll_layout)
        self.scroll_area.setWidget(self.scroll_content)
        left_layout.addWidget(self.scroll_area)

        # Select all / Deselect all
        btn_layout = QHBoxLayout()
        self.select_all_btn = QPushButton(tr("SELECT_ALL_IN_MULTIPLE_EDIT"))
        self.deselect_all_btn = QPushButton(tr("DESELECT_ALL_IN_MULTIPLE_EDIT"))
        self.select_all_btn.clicked.connect(self.select_all_portals)
        self.deselect_all_btn.clicked.connect(self.deselect_all_portals)
        btn_layout.addWidget(self.select_all_btn)
        btn_layout.addWidget(self.deselect_all_btn)
        left_layout.addLayout(btn_layout)

        # Information viewer
        self.view_portals_btn = QPushButton(tr("SEE_DATA"))
        self.view_portals_btn.clicked.connect(self.open_portal_info_viewer)
        left_layout.addWidget(self.view_portals_btn)

        # Right: Mass editing
        right_widget = QWidget()
        right_layout = QGridLayout(right_widget)
        splitter.addWidget(left_widget)
        splitter.addWidget(right_widget)

        splitter.setSizes([100, 380])

        main_layout = QVBoxLayout(self)
        main_layout.addWidget(splitter)

        row = 0

        # Executor
        self.executor_label = QLabel(tr("EXECUTOR"))
        self.executor_combo = QComboBox()

        # List of available executors
        executors = ["AzaharPlus", "Cemu", "Dolphin", "Duckstation", "Eden", "Flycast", "Linux", "MelonDS", "mGBA", "PCSX2", "PPSSPP", "RPCS3", "Ryubing", "Snes9x", "UMU"]
        self.executor_combo.insertItem(0, tr("DO_NOT_CHANGE"))
        self.executor_combo.setCurrentIndex(0)
        for executor in executors:
            self.executor_combo.addItem(executor, userData=executor)
        right_layout.addWidget(self.executor_label, row, 0)
        right_layout.addWidget(self.executor_combo, row, 1, 1, 2)
        row += 1

        # Game path
        self.game_label = QLabel(tr("GAME_PATH"))
        self.game_input = QLineEdit(tr("DO_NOT_CHANGE"))
        self.game_button = QPushButton(tr("BROWSE_BUTTON"))
        self.game_button.clicked.connect(self.select_file)
        right_layout.addWidget(self.game_label, row, 0)
        right_layout.addWidget(self.game_input, row, 1)
        right_layout.addWidget(self.game_button, row, 2)
        row += 1

        # Art path
        self.art_label = QLabel(tr("PORTAL_ART_PATH"))
        self.art_input = QLineEdit(tr("DO_NOT_CHANGE"))
        self.art_button = QPushButton(tr("BROWSE_BUTTON"))
        self.art_button.clicked.connect(self.select_portal_art)
        right_layout.addWidget(self.art_label, row, 0)
        right_layout.addWidget(self.art_input, row, 1)
        right_layout.addWidget(self.art_button, row, 2)
        row += 1

        # Gui icon path
        self.gui_label = QLabel(tr("PORTAL_GUI_PATH"))
        self.gui_input = QLineEdit(tr("DO_NOT_CHANGE"))
        self.gui_button = QPushButton(tr("BROWSE_BUTTON"))
        self.gui_button.clicked.connect(self.select_portal_gui)
        right_layout.addWidget(self.gui_label, row, 0)
        right_layout.addWidget(self.gui_input, row, 1)
        right_layout.addWidget(self.gui_button, row, 2)
        row += 1

        # Language
        self.lang_label = QLabel(tr("PORTAL_LANGUAGE"))
        self.lang_combo = QComboBox()
        self.lang_combo.addItems([
            tr("DO_NOT_CHANGE"),
            tr("PLACEHOLDER_FOR_LANGUAGE")
        ] + PORTAL_LOCALE_OPTIONS)
        self.lang_combo.setCurrentIndex(0)
        right_layout.addWidget(self.lang_label, row, 0)
        right_layout.addWidget(self.lang_combo, row, 1, 1, 2)
        row += 1

        self.gamemode_checkbox = QCheckBox(tr("GAMEMODE"))
        self.gamemode_checkbox.setTristate(True)
        self.gamemode_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        right_layout.addWidget(self.gamemode_checkbox, row, 0, 1, 3)
        row += 1

        # FPS HUD
        self.show_fps_checkbox = QCheckBox(tr("SHOW_FPS_OPTION"))
        self.show_fps_checkbox.setTristate(True)
        self.show_fps_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        self.fps_hud_combo = QComboBox()
        self.fps_hud_options = [("FPS_GALLIUM_HUD", tr("FPS_GALLIUM_HUD")), ("FPS_DXVK_HUD", tr("FPS_DXVK_HUD"))]
        for id, text in self.fps_hud_options:
            self.fps_hud_combo.addItem(text, id)
        self.fps_hud_combo.setEnabled(False)
        self.show_fps_checkbox.stateChanged.connect(self.update_fps_hud_state)
        right_layout.addWidget(self.show_fps_checkbox, row, 0)
        right_layout.addWidget(self.fps_hud_combo, row, 1, 1, 3)
        row += 1

        # Env vars
        self.env_label = QLabel(tr("ENVIRONMENT_VARS"))
        self.env_input = QLineEdit(tr("DO_NOT_CHANGE"))
        right_layout.addWidget(self.env_label, row, 0)
        right_layout.addWidget(self.env_input, row, 1, 1, 2)
        row += 1

        # Portal args
        self.args_label = QLabel(tr("PORTAL_ARGS"))
        self.args_input = QLineEdit(tr("DO_NOT_CHANGE"))
        right_layout.addWidget(self.args_label, row, 0)
        right_layout.addWidget(self.args_input, row, 1, 1, 2)
        row += 1

        self.add_default_clear(self.game_input)
        self.add_default_clear(self.art_input)
        self.add_default_clear(self.gui_input)
        self.add_default_clear(self.env_input)
        self.add_default_clear(self.args_input)

        # Reset and save buttons
        self.reset_button = QPushButton(tr("RESET_BUTTON_MULTIPLE_EDIT"))
        self.reset_button.clicked.connect(self.reset_fields)

        self.save_button = QPushButton(tr("SAVE_BUTTON"))
        self.save_button.clicked.connect(self.apply_multiple_edit)

        buttons_layout = QHBoxLayout()
        buttons_layout.addStretch()
        buttons_layout.addWidget(self.reset_button)
        buttons_layout.addWidget(self.save_button)

        right_layout.addLayout(buttons_layout, row, 0, 1, 3)

        # Loads portals
        self.portal_checkboxes = {}
        self.load_portals()

    # Auxiliary functions

    # Select or deselect innovations listed in the Portal Viewer.
    def set_checked_state(self, inv_name, state: bool):
        for checkbox in self.portal_checkboxes.values():
            try:
                if checkbox.text() == inv_name:
                    checkbox.setChecked(state)
            except Exception:
                continue

    def closeEvent(self, event):
        viewer = getattr(self, "portal_info_viewer", None)
        if viewer and viewer.isVisible():
            viewer.close()
        super().closeEvent(event)

    def open_portal_info_viewer(self):
        if getattr(self, "portal_info_viewer", None) and self.portal_info_viewer.isVisible():
            self.portal_info_viewer.raise_()
            self.portal_info_viewer.activateWindow()
            return

        self.portal_info_viewer = PortalInfoViewerDialog(meganimus_dir, self, multiple_edit_dialog=self)
        self.portal_info_viewer.finished.connect(partial(setattr, self, "portal_info_viewer", None))
        self.portal_info_viewer.show()

    def update_portal_list(self):
        text = self.search_input.text().lower()
        selected_executor = self.executor_filter.currentText()

        for name, cb in self.portal_checkboxes.items():
            try:
                with open(cb.portal_file, encoding="utf-8") as f:
                    data = toml.load(f)
                executor = data.get("executor", "Linux")
            except Exception:
                executor = "Linux"

            matches_text = text in name.lower()
            matches_executor = (selected_executor == tr("ALL_PORTALS")) or (executor == selected_executor)
            cb.setVisible(matches_text and matches_executor)

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def add_default_clear(self, line_edit):
        original_keyPressEvent = line_edit.keyPressEvent

        def new_keyPressEvent(event):
            if line_edit.text() == tr("DO_NOT_CHANGE"):
                line_edit.clear()
            # Invoke normal QLineEdit behavior
            original_keyPressEvent(event)

        line_edit.keyPressEvent = new_keyPressEvent

    def eventFilter(self, obj, event):
        if isinstance(obj, QLineEdit) and event.type() == QEvent.Type.FocusIn:
            if obj.text() == tr("DO_NOT_CHANGE"):
                obj.clear()
        return super().eventFilter(obj, event)

    def update_fps_hud_state(self, state):
        self.fps_hud_combo.setEnabled(Qt.CheckState(state) == Qt.CheckState.Checked)

    def select_file(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_GAME"),
            "",
            "",
        )
        if file_path:
            self.game_input.setText(file_path)

    def select_portal_art(self):
        heroes_dir = meganimus_dir / "sgdb" / "heroes"
        heroes_dir.mkdir(parents=True, exist_ok=True)

        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_PORTAL_ART"),
            str(heroes_dir),
            tr("IMAGE_FILTER")
        )
        if file_path:
            self.art_input.setText(file_path)

    def select_portal_gui(self):
        icons_dir = meganimus_dir / "sgdb" / "icons"
        icons_dir.mkdir(parents=True, exist_ok=True)

        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_PORTAL_GUI"),
            str(icons_dir),
            tr("IMAGE_FILTER")
        )
        if file_path:
            self.gui_input.setText(file_path)

    def update_executor_filter(self):
        """Updates the available executors in the filter based on the portal-info files."""
        executors = set()
        for cb in self.portal_checkboxes.values():
            try:
                with open(cb.portal_file, encoding="utf-8") as f:
                    data = toml.load(f)
                executor = data.get("executor", "Linux")
                executors.add(executor)
            except Exception:
                continue

        current = self.executor_filter.currentText()
        self.executor_filter.blockSignals(True)
        self.executor_filter.clear()
        self.executor_filter.addItem(tr("ALL_PORTALS"))
        for executor in sorted(executors):
            self.executor_filter.addItem(executor)
        index = self.executor_filter.findText(current)
        if index != -1:
            self.executor_filter.setCurrentIndex(index)
        self.executor_filter.blockSignals(False)

    def load_portals(self):
        self.portal_checkboxes.clear()
        while self.scroll_layout.count():
            item = self.scroll_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
        portal_files = sorted(meganimus_config_dir.glob("portal-info-*.toml"))
        for portal_file in portal_files:
            try:
                with open(portal_file, encoding="utf-8") as f:
                    data = toml.load(f)
                name = data.get("name", portal_file.stem)
                cb = QCheckBox(name)
                cb.portal_file = portal_file
                self.scroll_layout.addWidget(cb)
                self.portal_checkboxes[name] = cb
            except Exception:
                continue
        self.scroll_layout.addStretch()

        self.update_executor_filter()

    def select_all_portals(self):
        for cb in self.portal_checkboxes.values():
            if cb.isVisible():
                cb.setChecked(True)

    def deselect_all_portals(self):
        for cb in self.portal_checkboxes.values():
            if cb.isVisible():
                cb.setChecked(False)

    def reset_fields(self):
        # Runner
        self.executor_combo.setCurrentIndex(0)

        # Game / Art
        self.game_input.setText(tr("DO_NOT_CHANGE"))
        self.art_input.setText(tr("DO_NOT_CHANGE"))
        self.gui_input.setText(tr("DO_NOT_CHANGE"))

        # Language
        self.lang_combo.setCurrentIndex(0)

        # Checkboxes
        self.gamemode_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)

        # FPS HUD
        self.show_fps_checkbox.setCheckState(Qt.CheckState.PartiallyChecked)
        self.fps_hud_combo.setCurrentIndex(0)
        self.fps_hud_combo.setEnabled(False)

        # Env vars / Args
        self.env_input.setText(tr("DO_NOT_CHANGE"))
        self.args_input.setText(tr("DO_NOT_CHANGE"))

    # Apply changes
    def apply_multiple_edit(self):
        selected = [cb for cb in self.portal_checkboxes.values() if cb.isChecked()]
        if not selected:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_PORTAL_SELECTED_MULTIPLE"))
            return

        for cb in selected:
            with open(cb.portal_file, encoding="utf-8") as f:
                data = toml.load(f)

            # Apply fields
            # Executor
            executor = self.executor_combo.currentText()
            if executor != tr("DO_NOT_CHANGE"):
                data["executor"] = executor

            # Game
            game_path = self.game_input.text()
            if game_path != tr("DO_NOT_CHANGE"):
                data["game_path"] = game_path

            # Art
            art_input_text = self.art_input.text().strip()
            if art_input_text != tr("DO_NOT_CHANGE"):
                if not art_input_text:
                    # Remove previous file if it exists.
                    if data.get("art_path"):
                        old_art_path = Path(data["art_path"])
                        if old_art_path.exists() and old_art_path.is_file():
                            try:
                                old_art_path.unlink()
                            except Exception:
                                pass
                    data["art_path"] = ""
                else:
                    art_path = Path(art_input_text)
                    if art_path.exists() and art_path.is_file():
                        # Remove previous file if it exists.
                        if data.get("art_path"):
                            old_art_path = Path(data["art_path"])
                            if old_art_path.exists() and old_art_path.is_file():
                                try:
                                    old_art_path.unlink()
                                except Exception:
                                    pass

                        art_dir = meganimus_dir / "art"
                        art_dir.mkdir(parents=True, exist_ok=True)
                        ext = art_path.suffix.lower()
                        new_art_path = art_dir / f"{data['name'].replace(' ', '_').lower()}{ext}"
                        try:
                            shutil.copyfile(art_path, new_art_path)
                            data["art_path"] = str(new_art_path)
                        except Exception:
                            data["art_path"] = ""

            # Gui
            gui_input_text = self.gui_input.text().strip()
            if gui_input_text != tr("DO_NOT_CHANGE"):
                if not gui_input_text:
                    # Remove previous file if it exists.
                    if data.get("gui_path"):
                        old_gui_path = Path(data["gui_path"])
                        if old_gui_path.exists() and old_gui_path.is_file():
                            try:
                                old_gui_path.unlink()
                            except Exception:
                                pass
                    data["gui_path"] = ""
                else:
                    gui_path = Path(gui_input_text)
                    if gui_path.exists() and gui_path.is_file():
                        # Remove GUI antiga se existir
                        if data.get("gui_path"):
                            old_gui_path = Path(data["gui_path"])
                            if old_gui_path.exists() and old_gui_path.is_file():
                                try:
                                    old_gui_path.unlink()
                                except Exception:
                                    pass

                        gui_dir = meganimus_dir / "art" / "gui"
                        gui_dir.mkdir(parents=True, exist_ok=True)
                        ext = gui_path.suffix.lower()
                        new_gui_path = gui_dir / f"{data['name'].replace(' ', '_').lower()}{ext}"
                        try:
                            shutil.copyfile(gui_path, new_gui_path)
                            data["gui_path"] = str(new_gui_path)
                        except Exception:
                            data["gui_path"] = ""

            # Language
            lang = self.lang_combo.currentText()
            if lang != tr("DO_NOT_CHANGE"):
                data["language"] = "" if lang == tr("PLACEHOLDER_FOR_LANGUAGE") else lang

            # Checkboxes
            def apply_checkbox(cb_widget, key):
                state = cb_widget.checkState()
                if state != Qt.CheckState.PartiallyChecked:
                    data[key] = (state == Qt.CheckState.Checked)
            apply_checkbox(self.gamemode_checkbox, "use_gamemode")

            # FPS HUD
            if self.show_fps_checkbox.checkState() == Qt.CheckState.Checked:
                data["show_fps"] = True
                data["fps_hud_type"] = self.fps_hud_combo.currentData()
            elif self.show_fps_checkbox.checkState() == Qt.CheckState.Unchecked:
                data["show_fps"] = False
                data["fps_hud_type"] = self.fps_hud_combo.currentData()

            # Env vars
            env_vars = self.env_input.text()
            if env_vars != tr("DO_NOT_CHANGE"):
                data["env_vars"] = env_vars.strip()

            # Portal args
            args = self.args_input.text()
            if args != tr("DO_NOT_CHANGE"):
                data["portal_args"] = args.strip()

            # Save TOML
            with open(cb.portal_file, "w", encoding="utf-8") as f:
                toml.dump(data, f)

        self.update_executor_filter()
        self.update_portal_list()

        if self.parent_ref:
            self.parent_ref.load_portals()

        # Updates the right panel of the PortalInfoViewerDialog.
        if hasattr(self, "portal_info_viewer") and self.portal_info_viewer:
            self.portal_info_viewer.reload_current_selection()

        QMessageBox.information(
            self,
            tr("MULTIPLE_PORTAL_EDITOR"),
            tr("CHANGES_SAVED"))

class PortalInfoViewerDialog(QDialog):
    def __init__(self, meganimus_dir=None, parent=None, multiple_edit_dialog=None):
        super().__init__(parent)
        self.multiple_edit_dialog = multiple_edit_dialog
        self.setWindowTitle(tr("PORTAL_INFO_VIEWER_TITLE"))
        self.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose, True)
        if parent is not None:
            self.destroyed.connect(partial(setattr, parent, "portal_info_viewer", None))
        self.resize(580, 480)

        self.portals = self.load_portals()

        # Left widget: Search, combobox, list
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)

        # Search bar
        self.search_box = QLineEdit()
        self.search_box.setPlaceholderText(tr("SEARCH"))
        self.search_box.textChanged.connect(self.filter_portals)
        left_layout.addWidget(self.search_box)

        # Combobox for search
        self.search_mode_combo = QComboBox()
        self.search_mode_combo.addItems([tr("NAME"), tr("CONTENT")])
        self.search_mode_combo.currentIndexChanged.connect(self.update_filter_from_combo)
        left_layout.addWidget(self.search_mode_combo)

        # Scroll area for radio buttons
        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)
        self.container = QWidget()
        self.scroll_layout = QVBoxLayout(self.container)
        self.scroll_layout.setContentsMargins(6, 6, 6, 6)
        self.scroll_layout.setSpacing(4)
        self.scroll.setWidget(self.container)
        left_layout.addWidget(self.scroll)

        # mark/unmark listed buttons (added)
        self.btn_mark_listed = QPushButton(tr("MARK_LISTED"))
        self.btn_unmark_listed = QPushButton(tr("UNMARK_LISTED"))

        self.btn_mark_listed.clicked.connect(self.mark_listed)
        self.btn_unmark_listed.clicked.connect(self.unmark_listed)

        left_layout.addWidget(self.btn_mark_listed)
        left_layout.addWidget(self.btn_unmark_listed)

        # Radio button group
        self.button_group = QButtonGroup(self)
        self.button_group.setExclusive(True)
        self.button_group.buttonToggled.connect(self.handle_button_toggled)

        # Text box
        self.text_box = QTextEdit()
        self.text_box.setReadOnly(True)
        self.text_box.setAcceptRichText(True)
        self.text_box.setTextInteractionFlags(Qt.TextInteractionFlag.TextSelectableByMouse)

        # Styling
        palette = QApplication.palette()
        base_color = palette.color(QPalette.ColorRole.Base)
        text_color = palette.color(QPalette.ColorRole.Text)
        accent_color = palette.color(QPalette.ColorRole.Highlight)

        self.text_box.setStyleSheet(f"""
            QTextEdit {{
                background-color: {base_color.name()};
                color: {text_color.name()};
            }}
        """)

        # Qsplitter and main layout
        splitter = QSplitter(Qt.Orientation.Horizontal)
        splitter.addWidget(left_widget)
        splitter.addWidget(self.text_box)
        splitter.setChildrenCollapsible(False)

        splitter.setSizes([200, 460])

        main_layout = QHBoxLayout(self)
        main_layout.setContentsMargins(6, 6, 6, 6)
        main_layout.addWidget(splitter)

        self.radio_buttons = []
        self.create_portal_buttons()

    def update_filter_from_combo(self):
        current_text = self.search_box.text()
        self.filter_portals(current_text)

    # In the MultipleEditPortalDialog, mark all the innovations that are visible
    def mark_listed(self):
        if not getattr(self, "multiple_edit_dialog", None):
            return

        listed = []
        for rb in self.radio_buttons:
            if rb.isVisible():
                listed.append(rb.text())

        for name in listed:
            self.multiple_edit_dialog.set_checked_state(name, True)

    # In the Multiple Edit Portal Dialog, uncheck all the innovations that are visible
    def unmark_listed(self):
        if not getattr(self, "multiple_edit_dialog", None):
            return

        listed = []
        for rb in self.radio_buttons:
            if rb.isVisible():
                listed.append(rb.text())

        for name in listed:
            self.multiple_edit_dialog.set_checked_state(name, False)

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def closeEvent(self, event):
        # Notifies the MultipleEditPortalDialog that this dialog has been closed.
        if hasattr(self.parent(), "portal_info_viewer"):
            self.parent().portal_info_viewer = None
        super().closeEvent(event)

    # Loads the available TOML files.
    def load_portals(self) -> list[dict]:
        portals = []
        if not meganimus_config_dir.exists():
            return portals

        for file in meganimus_config_dir.glob("portal-info-*.toml"):
            try:
                with open(file, "r", encoding="utf-8") as f:
                    inv = toml.load(f)
                    inv["__filename"] = file.name
                    portals.append(inv)
            except Exception:
                pass
        return portals

    # Create radio buttons
    def create_portal_buttons(self):
        # Sort alphabetically by filename (portal-info-)
        def get_filename_sort_key(portal):
            filename = portal.get("__filename", "")
            return Path(filename).stem.lower()
        
        self.portals.sort(key=get_filename_sort_key)

        first_rb = None
        for inv in self.portals:
            filename = inv.get("__filename", "")
            display_name = inv.get("name") or inv.get("display_name") or inv.get("id")
            rb = QRadioButton(display_name)
            rb.setProperty("portal_filename", filename)
            self.button_group.addButton(rb)
            self.scroll_layout.addWidget(rb)
            self.radio_buttons.append(rb)
            if first_rb is None:
                first_rb = rb

        self.scroll_layout.addStretch(1)

        # Initial Selection
        if first_rb:
            first_rb.setChecked(True)
            self.show_portal_info_from_file(first_rb.property("portal_filename"))

    # Search filter
    def filter_portals(self, text: str):
        text = (text or "").strip().lower()
        first_visible = None
        search_mode = self.search_mode_combo.currentText()

        for rb in self.radio_buttons:
            filename = rb.property("portal_filename")
            match = False

            if search_mode == tr("NAME"):
                match = text in rb.text().lower()
            else:  # Content
                file_path = meganimus_dir / "config" / filename
                if file_path.exists():
                    try:
                        with open(file_path, "r", encoding="utf-8") as f:
                            data = toml.load(f)
                        # Search for content only in these fields
                        for key in ["game_path", "language", "env_vars", "portal_args"]:
                            value = str(data.get(key, "")).lower()
                            if text in value:
                                match = True
                                break
                    except Exception:
                        match = False

            rb.setVisible(match)
            if match and first_visible is None:
                first_visible = rb

        if first_visible:
            first_visible.setChecked(True)

            checked = self.button_group.checkedButton()
            if checked:
                filename = checked.property("portal_filename")
                self.show_portal_info_from_file(filename)
        else:
            self.text_box.clear()

    # When a radio button is clicked
    def handle_button_toggled(self, button, checked: bool):
        if not checked or not button:
            return
        filename = button.property("portal_filename")
        if filename:
            self.show_portal_info_from_file(filename)

    # Display information by reading the TOML.
    def show_portal_info_from_file(self, filename: str):
        file_path = meganimus_dir / "config" / filename
        if not file_path.exists():
            self.text_box.clear()
            return

        try:
            with open(file_path, "r", encoding="utf-8") as f:
                inv = toml.load(f)
        except Exception:
            self.text_box.clear()
            return

        self.text_box.clear()
        cursor = self.text_box.textCursor()
        palette = QApplication.palette()
        key_color = palette.color(QPalette.ColorRole.Highlight)
        value_color = palette.color(QPalette.ColorRole.Text)

        translations = {
            "name": tr("PORTAL_NAME"),
            "executor": tr("EXECUTOR"),
            "game_path": tr("GAME_PATH"),
            "art_path": tr("PORTAL_ART_PATH"),
            "gui_path": tr("PORTAL_GUI_PATH"),
            "language": tr("PORTAL_LANGUAGE"),
            "use_gamemode": tr("GAMEMODE"),
            "show_fps": tr("SHOW_FPS_OPTION"),
            "fps_hud_type": tr("SHOW_FPS_OPTION_HUD"),
            "env_vars": tr("ENVIRONMENT_VARS"),
            "portal_args": tr("PORTAL_ARGS"),
        }

        value_translations = {
            "FPS_GALLIUM_HUD": tr("FPS_GALLIUM_HUD"),
            "FPS_DXVK_HUD": tr("FPS_DXVK_HUD")
        }

        for key, value in inv.items():
            if isinstance(value, bool):
                value = "✅" if value else "❌"

            if isinstance(value, str) and value in value_translations:
                value = value_translations[value]
                value = re.sub(r"\s*\(.*?\)", "", value).strip()

            key_label = translations.get(key, key)

            fmt_key = QTextCharFormat()
            fmt_key.setForeground(QColor(key_color))

            fmt_value = QTextCharFormat()
            fmt_value.setForeground(QColor(value_color))

            cursor.insertText(f"{key_label}: ", fmt_key)
            cursor.insertText(str(value) + "\n", fmt_value)

        self.text_box.moveCursor(QTextCursor.MoveOperation.Start)

    # Updates the right panel while maintaining the selection.
    def reload_current_selection(self):
        checked_button = self.button_group.checkedButton()
        if checked_button:
            filename = checked_button.property("portal_filename")
            self.show_portal_info_from_file(filename)

class ShortcutManager(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("SHORTCUTS_MANAGER_TITLE"))
        self.resize(340, 400)

        # Load portals and shortcuts info
        self.portals = self.load_portals()
        self.shortcut_manager_info = self.load_shortcut_manager_info()

        # Current view: "desktop" or "menu"
        self.current_view = "desktop"
        self.checkbox_states = {"desktop": {}, "menu": {}}
        self.checkbox_widgets = {"desktop": {}, "menu": {}}

        # UI
        main_layout = QVBoxLayout(self)

        # Search bar
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText(tr("SEARCH"))
        self.search_bar.textChanged.connect(self.update_list_view)
        main_layout.addWidget(self.search_bar)

        # ComboBox to switch view
        self.view_combo = QComboBox()
        self.view_combo.addItems([tr("SHORTCUTS_OF_DESKTOP"), tr("SHORTCUTS_OF_MENU")])
        self.view_combo.currentIndexChanged.connect(self.update_list_view)
        main_layout.addWidget(self.view_combo)

        # Scroll area for checkboxes
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)
        self.scroll_layout.setContentsMargins(6, 6, 6, 6)
        self.scroll_layout.setSpacing(4)
        self.scroll_content.setLayout(self.scroll_layout)
        self.scroll_area.setWidget(self.scroll_content)
        main_layout.addWidget(self.scroll_area)

        # Select / Deselect All buttons
        select_layout = QHBoxLayout()
        self.select_all_btn = QPushButton(tr("SELECT_ALL_IN_MULTIPLE_EDIT"))
        self.select_all_btn.clicked.connect(self.select_all_checkboxes)
        self.deselect_all_btn = QPushButton(tr("DESELECT_ALL_IN_MULTIPLE_EDIT"))
        self.deselect_all_btn.clicked.connect(self.deselect_all_checkboxes)
        select_layout.addWidget(self.select_all_btn)
        select_layout.addWidget(self.deselect_all_btn)
        main_layout.addLayout(select_layout)

        # Own category checkbox
        self.own_category_cb = QCheckBox(tr("OWN_CATEGORY"))
        own_category_checked = self.shortcut_manager_info.get("own_category", False)

        # Uncheck and disable if running inside Snap
        if os.environ.get("SNAP"):
            own_category_checked = False
            self.own_category_cb.setEnabled(False)

        self.own_category_cb.setChecked(own_category_checked)
        main_layout.addWidget(self.own_category_cb)

        # Folder selection
        grid = QGridLayout()

        # Desktop section
        grid.addWidget(QLabel(tr("DESKTOP_FOLDER")), 0, 0)
        self.desktop_dir_input = QLineEdit(self.shortcut_manager_info.get("desktop_dir", ""))
        grid.addWidget(self.desktop_dir_input, 1, 0, 1, 3)

        desktop_buttons = QHBoxLayout()
        desktop_browse = QPushButton(tr("BROWSE_BUTTON"))
        desktop_browse.clicked.connect(partial(self.browse_folder, self.desktop_dir_input))
        desktop_buttons.addWidget(desktop_browse)
        grid.addLayout(desktop_buttons, 2, 0, 1, 3)

        # Menu section  
        grid.addWidget(QLabel(tr("MENU_FOLDER")), 3, 0)
        self.menu_dir_input = QLineEdit(self.shortcut_manager_info.get("menu_dir", ""))
        grid.addWidget(self.menu_dir_input, 4, 0, 1, 3)

        menu_buttons = QHBoxLayout()
        menu_browse = QPushButton(tr("BROWSE_BUTTON"))
        menu_browse.clicked.connect(partial(self.browse_folder, self.menu_dir_input))
        menu_buttons.addWidget(menu_browse)
        grid.addLayout(menu_buttons, 5, 0, 1, 3)

        grid.setContentsMargins(0, 0, 0, 0)

        self.locations_widget = QWidget()
        self.locations_widget.setLayout(grid)
        self.locations_widget.hide()
        main_layout.addWidget(self.locations_widget)

        # Show locations and update button
        buttons_layout = QHBoxLayout()
        self.locations_btn = QPushButton(tr("SHORTCUTS_PATHS"))
        self.locations_btn.clicked.connect(self.toggle_locations)
        buttons_layout.addWidget(self.locations_btn)
        buttons_layout.addStretch()
        self.update_shortcuts = QPushButton(tr("UPDATE_SHORTCUTS"))
        self.update_shortcuts.clicked.connect(self.update_and_apply)
        buttons_layout.addWidget(self.update_shortcuts)
        main_layout.addLayout(buttons_layout)

        self.update_list_view()
        self.view_combo.setCurrentIndex(1)
        self.update_list_view()
        self.view_combo.setCurrentIndex(0)

    def toggle_locations(self):
        self.locations_widget.setVisible(not self.locations_widget.isVisible())

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def is_meganimus_desktop(self, file_path: Path) -> bool:
        if not file_path.exists() or file_path.suffix != ".desktop":
            return False

        if not file_path.stem.startswith("portal-"):
            return False

        try:
            content = file_path.read_text(encoding="utf-8")
            return '--start-portal' in content
        except Exception:
            return False

    # Checkbox Helpers
    def select_all_checkboxes(self):
        for cb in self.checkbox_widgets[self.current_view].values():
            if cb.isVisible():
                cb.setChecked(True)

    def deselect_all_checkboxes(self):
        for cb in self.checkbox_widgets[self.current_view].values():
            if cb.isVisible():
                cb.setChecked(False)

    # List view update
    def update_list_view(self):
        # Save current states
        for name, cb in self.checkbox_widgets[self.current_view].items():
            self.checkbox_states[self.current_view][name] = cb.isChecked()

        # Define current view
        self.current_view = "desktop" if self.view_combo.currentIndex() == 0 else "menu"

        # Current folder and existing desktops
        folder_path = Path(self.shortcut_manager_info.get(f"{self.current_view}_dir", ""))
        existing_desktops = set()

        if folder_path.exists():
            safe_to_display = {data["safe_portal_name"]: name
                              for name, data in self.portals.items()
                              if "safe_portal_name" in data}

            for f in folder_path.glob("portal-*.desktop"):
                if self.is_meganimus_desktop(f):
                    safe_name = f.stem.replace("portal-", "")
                    if safe_name in safe_to_display:
                        existing_desktops.add(safe_to_display[safe_name])

        # Clean up the old layout.
        while self.scroll_layout.count():
            item = self.scroll_layout.takeAt(0)
            if item.widget():
                item.widget().setParent(None)

        # Create/recreate checkboxes for this view.
        new_checkboxes = {}
        for inv in sorted(self.portals.keys()):
            cb = QCheckBox(inv)
            cb.setChecked(self.checkbox_states[self.current_view].get(inv, inv in existing_desktops))
            new_checkboxes[inv] = cb
        self.checkbox_widgets[self.current_view] = new_checkboxes

        # Add only widgets filtered by the search.
        text = self.search_bar.text().lower()
        for name, cb in self.checkbox_widgets[self.current_view].items():
            if text in name.lower():
                self.scroll_layout.addWidget(cb)
                cb.show()
            else:
                cb.hide()

        self.scroll_layout.addStretch()

    # Loading and saving
    def load_portals(self) -> dict:
        invs = {}
        if not meganimus_config_dir.exists():
            return invs
        for f in meganimus_config_dir.glob("portal-info-*.toml"):
            try:
                content = f.read_text(encoding="utf-8")
                data = toml.loads(content)
                name = data.get("name")
                gui_path = data.get("gui_path", "")
                safe_portal_name = f.stem.replace("portal-info-", "")
                if name:
                    invs[name] = {"gui_path": gui_path, "safe_portal_name": safe_portal_name}
            except Exception:
                continue
        return invs

    def load_shortcut_manager_info(self):
        """Load menu_dir, desktop_dir and meganimus_command from TOML settings."""
        settings = load_settings()
        shortcut_section = settings.get("shortcut", {})

        # Get values from config or empty strings
        desktop_dir = shortcut_section.get("desktop_dir", "")
        menu_dir = shortcut_section.get("menu_dir", "")
        
        meganimus_command = shortcut_section.get("meganimus_command", "meganimus")
        own_category = shortcut_section.get("own_category", False)

        # If desktop_dir is empty in config, calculate default
        if not desktop_dir:
            desktop_dir = home_dir / "Desktop"  # fallback
            user_dirs_file = home_dir / ".config" / "user-dirs.dirs"
            if user_dirs_file.exists():
                try:
                    with open(user_dirs_file, encoding="utf-8") as f:
                        for line in f:
                            line = line.strip()
                            if line.startswith("XDG_DESKTOP_DIR"):
                                path = line.split("=", 1)[1].strip().strip('"')
                                path = path.replace("$HOME", str(home_dir))
                                desktop_dir = Path(path)
                                break
                except Exception:
                    pass

        # If menu_dir is empty in config, use default
        if not menu_dir:
            menu_dir = str(home_dir / ".local" / "share" / "applications")

        # Processed settings for shortcut manager
        info = {
            "desktop_dir": str(desktop_dir),
            "menu_dir": str(menu_dir),
            "meganimus_command": meganimus_command,
            "own_category": own_category,
            "menu_file": shortcut_section.get("menu_file", ""),
            "directory_file": shortcut_section.get("directory_file", "")
        }

        return info

    def save_shortcut_manager_info(self):
        """Save menu_dir and desktop_dir to TOML settings."""
        settings = load_settings()
        settings.setdefault("shortcut", {})
        settings["shortcut"]["desktop_dir"] = self.shortcut_manager_info.get("desktop_dir", "")
        settings["shortcut"]["menu_dir"] = self.shortcut_manager_info.get("menu_dir", "")
        settings["shortcut"]["own_category"] = self.own_category_cb.isChecked()
        settings["shortcut"]["menu_file"] = self.shortcut_manager_info.get("menu_file", "")
        settings["shortcut"]["directory_file"] = self.shortcut_manager_info.get("directory_file", "")
        save_settings(settings)

    # Folder browsing
    def browse_folder(self, line_edit: QLineEdit):
        if line_edit == self.desktop_dir_input:
            initial_dir = str(home_dir)
        else:
            initial_dir = str(home_dir / ".local" / "share" / "applications")
        
        folder = QFileDialog.getExistingDirectory(self, tr("SELECT_FOLDER"), initial_dir)
        if not folder:
            return

        new_folder = Path(folder)
        line_edit.setText(str(new_folder))

    # Save and create .desktop

    def remove_all_meganimus_desktops(self, folder: Path):
        if not folder.exists():
            return

        for f in folder.glob("portal-*.desktop"):
            try:
                if self.is_meganimus_desktop(f):
                    f.unlink()
            except Exception as e:
                print(tr("ERROR_REMOVING_FILE", file=f, error=e))

    def update_and_apply(self):
        menu_dir = Path(self.menu_dir_input.text().strip())
        desktop_dir = Path(self.desktop_dir_input.text().strip())

        try:
            desktop_dir.mkdir(parents=True, exist_ok=True)
        except Exception:
            QMessageBox.warning(
                self,
                tr("APP_NAME"),
                tr("ERROR_CREATING_SHORTCUTS_LOCATION", location=desktop_dir)
            )
            return

        try:
            menu_dir.mkdir(parents=True, exist_ok=True)
        except Exception:
            QMessageBox.warning(
                self,
                tr("APP_NAME"),
                tr("ERROR_CREATING_SHORTCUTS_LOCATION", location=menu_dir)
            )
            return

        old_desktop_dir = Path(self.shortcut_manager_info.get("desktop_dir", ""))
        old_menu_dir = Path(self.shortcut_manager_info.get("menu_dir", ""))
        
        self.remove_all_meganimus_desktops(old_desktop_dir)
        self.remove_all_meganimus_desktops(old_menu_dir)

        self.shortcut_manager_info["menu_dir"] = str(menu_dir)
        self.shortcut_manager_info["desktop_dir"] = str(desktop_dir)
        self.shortcut_manager_info["own_category"] = self.own_category_cb.isChecked()

        # Remove files if the own_category checkbox is unchecked.
        if not self.own_category_cb.isChecked():
            saved_menu_file = self.shortcut_manager_info.get("menu_file", "")
            saved_directory_file = self.shortcut_manager_info.get("directory_file", "")

            if saved_menu_file and Path(saved_menu_file).exists():
                try:
                    Path(saved_menu_file).unlink()
                except Exception as e:
                    print(tr("ERROR_REMOVING_FILE", file=saved_menu_file, error=e))

            if saved_directory_file and Path(saved_directory_file).exists():
                try:
                    Path(saved_directory_file).unlink()
                except Exception as e:
                    print(tr("ERROR_REMOVING_FILE", file=saved_directory_file, error=e))

            self.shortcut_manager_info["menu_file"] = ""
            self.shortcut_manager_info["directory_file"] = ""

        self.save_shortcut_manager_info()

        # Manage category files
        if self.own_category_cb.isChecked():
            try:
                dot_menu_file_path = home_dir / ".config" / "menus" / "applications-merged" / "Meganimus.menu"
                dot_menu_file_path.parent.mkdir(parents=True, exist_ok=True)
                
                menu_content = "\n".join([
                    "<Menu>",
                    "  <Name>Applications</Name>",
                    "  <Menu>",
                    "    <Name>Meganimus</Name>",
                    "    <Directory>Meganimus.directory</Directory>",
                    "    <Include>",
                    "      <Category>Meganimus</Category>",
                    "    </Include>",
                    "  </Menu>",
                    "</Menu>"
                ])
                dot_menu_file_path.write_text(menu_content, encoding="utf-8")
                self.shortcut_manager_info["menu_file"] = str(dot_menu_file_path)
            except Exception as e:
                print(tr("ERROR_CREATING_FILE", file="Meganimus.menu", error=e))
                self.shortcut_manager_info["menu_file"] = ""

            try:
                dot_directory_file_path = home_dir / ".local" / "share" / "desktop-directories" / "Meganimus.directory"
                dot_directory_file_path.parent.mkdir(parents=True, exist_ok=True)
                
                directory_content = "\n".join([
                    "[Desktop Entry]",
                    "Name=Meganimus",
                    "Icon=meganimus"
                ])
                dot_directory_file_path.write_text(directory_content, encoding="utf-8")
                self.shortcut_manager_info["directory_file"] = str(dot_directory_file_path)
            except Exception as e:
                print(tr("ERROR_CREATING_FILE", file="Meganimus.directory", error=e))
                self.shortcut_manager_info["directory_file"] = ""

            self.save_shortcut_manager_info()

        # Remove existing .desktop files.
        self.remove_all_meganimus_desktops(desktop_dir)
        self.remove_all_meganimus_desktops(menu_dir)

        # Create each type separately.
        for name, cb in self.checkbox_widgets["desktop"].items():
            checked = cb.isChecked()
            self.create_desktop_file(name, checked, desktop_dir)

        for name, cb in self.checkbox_widgets["menu"].items():
            checked = cb.isChecked()
            self.create_desktop_file(name, checked, menu_dir)

        os.system(f'chmod +x "{desktop_dir}/"portal-*.desktop')
        os.system(f'chmod +x "{menu_dir}/"portal-*.desktop')

        QMessageBox.information(self, tr("APP_NAME"), tr("SHORTCUTS_SAVED"))
        self.update_list_view()
        self.accept()

    def create_desktop_file(self, name: str, checked: bool, folder: Path):
        if not checked:
            return

        portal_data = self.portals.get(name, {})
        safe_name = portal_data.get("safe_portal_name", "")

        desktop_file = folder / f"portal-{safe_name}.desktop"

        if os.environ.get("SNAP"):
            current_meganimus = "snap run meganimus"
        else:
            current_meganimus = self.shortcut_manager_info.get("meganimus_command", "meganimus")

        current_meganimus += f' --start-portal "{name}"'

        gui_path = self.portals.get(name, {}).get("gui_path", "")

        categories = "Meganimus;" if self.own_category_cb.isChecked() else "Game;"

        content_lines = [
            "[Desktop Entry]",
            f"Name={name}",
            f"Exec={current_meganimus}",
            f"Icon={gui_path}",
            "StartupWMClass=meganimus",
            f"Categories={categories}",
            "Keywords=gaming;portal;",
            "Terminal=false",
            "Type=Application"
        ]

        try:
            with open(desktop_file, "w", encoding="utf-8") as f:
                f.write("\n".join(content_lines) + "\n")
        except Exception as e:
            print(tr("ERROR_CREATING_FILE", file=desktop_file, error=e))

class Meganimus(QMainWindow):
    def __init__(self):
        super().__init__()
        settings = load_settings()
        start_minimized = settings["window"].get("start_minimized", False)
        wanted = settings["design"].get("qt_style")

        size = settings["window"].get("windowSize")
        if size and isinstance(size, list) and len(size) == 2:
            self.resize(QSize(size[0], size[1]))
        else:
            self.resize(780, 640)

        # Only set if style exists on this system
        if wanted and wanted != "indefinite" and wanted in QStyleFactory.keys():
            QApplication.setStyle(wanted)
        self.setWindowTitle(tr("APP_NAME"))
        self.setMinimumSize(300, 160)
        self.portal_process = None

        # Add the icon to the main window
        local_icons = ['meganimus.svg', 'Meganimus.svg']

        icon_set = False
        for icon_file in local_icons:
            if Path(icon_file).exists():
                self.setWindowIcon(QIcon(icon_file))
                icon_set = True
                break
        if not icon_set:
            # Fallback to system theme icons
            for name in ['meganimus', 'Meganimus', 'applications-all']:
                icon = QIcon.fromTheme(name)
                if not icon.isNull():
                    self.setWindowIcon(icon)
                    break

        self.setup_directories()

        # Toolbar
        self.toolbar = QToolBar()
        self.toolbar.setMovable(True)
        self.toolbar.setFloatable(False)

        self.toolbar.setVisible(settings["design"].get("toolbar_visible", True))

        toolbar_position = settings["design"].get("toolbar_position", "top")

        if toolbar_position == "top":
            self.addToolBar(Qt.ToolBarArea.TopToolBarArea, self.toolbar)
        elif toolbar_position == "left":
            self.addToolBar(Qt.ToolBarArea.LeftToolBarArea, self.toolbar)
        elif toolbar_position == "right":
            self.addToolBar(Qt.ToolBarArea.RightToolBarArea, self.toolbar)
        elif toolbar_position == "bottom":
            self.addToolBar(Qt.ToolBarArea.BottomToolBarArea, self.toolbar)
        else:
            self.addToolBar(self.toolbar)  # fallback

        # MenuBar
        self.menu_bar = self.menuBar()

        # Menu PORTAL
        self.portal_menu = self.menu_bar.addMenu(tr("PORTAL"))

        # Add multiple portals
        self.multiple_create_portals_action = QAction(tr("CREATE_MULTIPLE_PORTALS"), self)
        self.multiple_create_portals_action.triggered.connect(self.multiple_create_portals)
        self.portal_menu.addAction(self.multiple_create_portals_action)

        # Remove multiple portals
        self.multiple_remove_portals_action = QAction(tr("REMOVE_MULTIPLE_PORTALS"), self)
        self.multiple_remove_portals_action.triggered.connect(self.multiple_remove_portals)
        self.portal_menu.addAction(self.multiple_remove_portals_action)

        # Edit multiple portals
        self.multiple_edit_portals_action = QAction(tr("EDIT_MULTIPLE_PORTALS"), self)
        self.multiple_edit_portals_action.triggered.connect(self.multiple_edit_portals)
        self.portal_menu.addAction(self.multiple_edit_portals_action)

        # Shortcut manager
        self.shortcut_manager_action = QAction(tr("MANAGE_SHORTCUTS"), self)
        self.shortcut_manager_action.triggered.connect(self.open_shortcut_manager_dialog)
        self.portal_menu.addAction(self.shortcut_manager_action)

        # Menu TRANSFER
        self.transfer_menu = self.menu_bar.addMenu(tr("TRANSFER"))

        self.transfer_arts_action = QAction(tr("TRANSFER_ARTS"), self)
        self.transfer_arts_action.triggered.connect(self.open_transfer_arts)
        self.transfer_menu.addAction(self.transfer_arts_action)

        # Menu EXTRAS
        self.extras_menu = self.menu_bar.addMenu(tr("EXTRAS"))

        self.settings_action = QAction(tr("MEGANIMUS_SETTINGS"), self)
        self.settings_action.triggered.connect(self.open_settings)
        self.extras_menu.addAction(self.settings_action)

        self.about_action = QAction(tr("ABOUT_MEGANIMUS"), self)
        self.about_action.triggered.connect(self.show_about)
        self.extras_menu.addAction(self.about_action)

        # Increase the size of icons
        toolbar_icon_size = settings["design"].get("toolbar_icon_size", 32)
        self.toolbar.setIconSize(QSize(toolbar_icon_size, toolbar_icon_size))

        self.run_action = QAction(QIcon.fromTheme("media-playback-start"), tr("START_PORTAL"), self)
        self.run_action.triggered.connect(self.start_selected_portal)
        self.toolbar.addAction(self.run_action)

        self.stop_execution_action = QAction(QIcon.fromTheme("media-playback-stop"), tr("STOP_PORTAL"), self)
        self.stop_execution_action.triggered.connect(self.stop_execution)
        self.toolbar.addAction(self.stop_execution_action)

        self.start_random_portal_action = QAction(QIcon.fromTheme("roll"), tr("START_RANDOM_PORTAL"), self)
        self.start_random_portal_action.triggered.connect(self.start_random_portal)
        self.toolbar.addAction(self.start_random_portal_action)

        self.add_portal_action = QAction(QIcon.fromTheme("list-add"), tr("CREATE_PORTAL"), self)
        self.add_portal_action.triggered.connect(self.add_portal)
        self.toolbar.addAction(self.add_portal_action)

        self.edit_portal_action = QAction(QIcon.fromTheme("document-edit"), tr("MODIFY_PORTAL"), self)
        self.edit_portal_action.triggered.connect(self.edit_portal)
        self.toolbar.addAction(self.edit_portal_action)

        self.search_action = QAction(QIcon.fromTheme("search"), tr("SEARCH"), self)
        self.search_action.triggered.connect(self.toggle_search_bar)
        self.toolbar.addAction(self.search_action)

        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.main_layout = QVBoxLayout()
        self.central_widget.setLayout(self.main_layout)

        if not settings["design"].get("toolbar_visible", True):
            self.central_widget.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            self.central_widget.customContextMenuRequested.connect(self.show_global_context_menu)

        self.toolbar.visibilityChanged.connect(self.save_toolbar_visibility)

        self.portal_list_widget = QListWidget()
        self.portal_list_widget.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)

        self._last_selected_items = []
        self.portal_list_widget.itemSelectionChanged.connect(self.ensure_selection)

        layout_mode = settings["design"].get("layout_mode", "classic")

        icon_width_classic = settings["design"].get("icon_width_classic", 420)
        icon_width_grid = settings["design"].get("icon_width_grid", 300)

        if layout_mode in ("list"):
            self.portal_list_widget.setViewMode(QListWidget.ViewMode.ListMode)
            self.portal_list_widget.setMovement(QListWidget.Movement.Static)
            self.portal_list_widget.setResizeMode(QListWidget.ResizeMode.Adjust)
        elif layout_mode in ("grid"):
            self.portal_list_widget.setViewMode(QListWidget.ViewMode.IconMode)
            self.portal_list_widget.setFlow(QListView.Flow.LeftToRight)
            self.portal_list_widget.setResizeMode(QListWidget.ResizeMode.Adjust)
            icon_width = icon_width_grid
            icon_height = int(icon_width * (620 / 1920))
            grid_width = icon_width + 5
            grid_height = icon_height + 30
            self.portal_list_widget.setIconSize(QSize(icon_width, icon_height))
            self.portal_list_widget.setGridSize(QSize(grid_width, grid_height))
            self.portal_list_widget.setMovement(QListWidget.Movement.Static)
        elif layout_mode in ("classic"):
            self.portal_list_widget.setViewMode(QListWidget.ViewMode.ListMode)
            self.portal_list_widget.setMovement(QListWidget.Movement.Static)
            self.portal_list_widget.setResizeMode(QListWidget.ResizeMode.Adjust)
            icon_width = icon_width_classic
            icon_height = int(icon_width * (620 / 1920))
            self.portal_list_widget.setIconSize(QSize(icon_width, icon_height))

        self.main_layout.addWidget(self.portal_list_widget)

        # Search bar and combobox
        self.search_widget = QWidget()
        self.search_layout = QHBoxLayout(self.search_widget)
        self.search_layout.setContentsMargins(0, 0, 0, 0)
        self.search_layout.setSpacing(0)

        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText(tr("SEARCH"))
        self.search_bar.textChanged.connect(self.filter_portals)

        self.executor_filter = QComboBox()
        self.executor_filter.addItem(tr("ALL_PORTALS"))
        self.executor_filter.currentTextChanged.connect(self.filter_portals)

        self.search_layout.addWidget(self.executor_filter)
        self.search_layout.addWidget(self.search_bar)

        self.main_layout.insertWidget(0, self.search_widget)

        self.load_portals()

        # Visibility based on Meganimus settings
        visible = settings["design"].get("search_bar_visible", False)
        self.search_bar.setVisible(visible)
        self.executor_filter.setVisible(visible)
        self.executor_filter.setCurrentIndex(settings["design"].get("executor_filter_index", 0))

        # ===== Context menu =====
        self.global_context_menu = QMenu(self)
        self.global_context_menu.clear()
        # Menu of toolbar
        self.global_context_menu.addAction(self.run_action)
        self.global_context_menu.addAction(self.stop_execution_action)
        self.global_context_menu.addAction(self.start_random_portal_action)
        self.global_context_menu.addAction(self.add_portal_action)
        self.global_context_menu.addAction(self.edit_portal_action)
        self.global_context_menu.addAction(self.search_action)
        self.global_context_menu.addSeparator()

        # ===== System Tray Icon =====
        self.tray_icon = QSystemTrayIcon(self)
        self.tray_icon.setIcon(self.windowIcon())
        self.tray_icon.setToolTip(self.windowTitle())
        self.windowTitleChanged.connect(self.tray_icon.setToolTip)

        tray_menu = QMenu()

        # Run random portal
        random_action = QAction(tr("START_RANDOM_PORTAL"), tray_menu)
        random_action.setIcon(QIcon.fromTheme("roll"))
        random_action.triggered.connect(self.start_random_portal)
        tray_menu.addAction(random_action)

        # Stop portal
        tray_menu.addAction(self.stop_execution_action)

        # Show/Hide Window
        self.restore_action = QAction(tr("MEGANIMUS_TRAY_TOGGLE"), self)
        self.restore_action.setIcon(QIcon.fromTheme("visibility"))
        self.restore_action.triggered.connect(self.toggle_window)
        tray_menu.addAction(self.restore_action)

        # Quit
        quit_action = QAction(tr("CLOSE_MEGANIMUS"), self)
        quit_action.setIcon(QIcon.fromTheme("dialog-close"))
        quit_action.triggered.connect(self.close)
        tray_menu.addAction(quit_action)

        self.tray_icon.setContextMenu(tray_menu)
        self.tray_icon.show()

        start_minimized = settings["window"].get("start_minimized", False)
        if start_minimized:
            self.hide()
        elif settings["window"].get("isFullScreen", False):
            self.showFullScreen()
        elif settings["window"].get("isMaximized", False):
            self.showMaximized()
        else:
            self.show()

        atexit.register(self.kill_portal_process_on_exit)
        self.transfer_successful = False

    def show_global_context_menu(self, pos):
        global_pos = self.central_widget.mapToGlobal(pos)
        self.global_context_menu.popup(global_pos)

    def save_toolbar_visibility(self, visible):
        settings = load_settings()
        settings["design"]["toolbar_visible"] = visible
        save_settings(settings)

        if not visible:
            self.central_widget.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            self.central_widget.customContextMenuRequested.connect(self.show_global_context_menu)
        else:
            self.central_widget.setContextMenuPolicy(Qt.ContextMenuPolicy.NoContextMenu)

    def toggle_search_bar(self):
        visible = not self.search_bar.isVisible()
        self.search_bar.setVisible(visible)
        self.executor_filter.setVisible(visible)
        if visible:
            self.search_bar.setFocus()
            self.search_bar.selectAll()
        else:
            self.search_bar.clear()
            self.executor_filter.setCurrentIndex(0)
            self.filter_portals("")

    def ensure_selection(self):
        selected_items = self.portal_list_widget.selectedItems()
        if not selected_items and self._last_selected_items:
            for item in self._last_selected_items:
                item.setSelected(True)
        else:
            self._last_selected_items = selected_items.copy()

    def start_random_portal(self):
        if self.portal_list_widget.count() == 0:
            QMessageBox.information(
                self, tr("APP_NAME"), tr("NO_PORTALS_FOUND"))
            return
        idx = random.randint(0, self.portal_list_widget.count() - 1)
        portal_name = self.portal_list_widget.item(idx).text()
        self.start_portal(portal_name)

    def toggle_window(self):
        if self.isVisible():
            self.hide()
        else:
            self.show()
            self.raise_()
            self.activateWindow()

    def closeEvent(self, event):
        settings = load_settings()
        settings["design"]["search_bar_visible"] = self.search_bar.isVisible()
        settings["design"]["executor_filter_index"] = self.executor_filter.currentIndex()
        settings["design"]["toolbar_visible"] = self.toolbar.isVisible()
        area = self.toolBarArea(self.toolbar)
        if area == Qt.ToolBarArea.TopToolBarArea:
            settings["design"]["toolbar_position"] = "top"
        elif area == Qt.ToolBarArea.LeftToolBarArea:
            settings["design"]["toolbar_position"] = "left"
        elif area == Qt.ToolBarArea.RightToolBarArea:
            settings["design"]["toolbar_position"] = "right"
        elif area == Qt.ToolBarArea.BottomToolBarArea:
            settings["design"]["toolbar_position"] = "bottom"
        settings["window"]["windowSize"] = [self.size().width(), self.size().height()]
        settings["window"]["isMaximized"] = self.isMaximized()
        settings["window"]["isFullScreen"] = self.isFullScreen()
        settings["window"]["start_minimized"] = not self.isVisible()
        # Checks if the title contains the string "PORTAL_STARTED"
        if self.windowTitle().startswith(tr("PORTAL_STARTED", portal_name="").split("{portal_name}")[0].strip()):
            reply = QMessageBox.question(
                self,
                tr("APP_NAME"),
                tr("CONFIRM_CLOSE_MESSAGE"),
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.Yes:
                self.stop_execution()
                save_settings(settings)
                QApplication.quit()
            else:
                event.ignore()
        else:
            save_settings(settings)
            QApplication.quit()

    def multiple_create_portals(self):
        dialog = MultipleCreatePortalsDialog(self)
        dialog.portals_saved.connect(self.load_portals)
        dialog.exec()

    def multiple_remove_portals(self):
        dialog = MultipleRemovePortalDialog(self)
        dialog.finished.connect(self.load_portals)
        dialog.exec()

    def multiple_edit_portals(self):
        dialog = MultipleEditPortalDialog(self)
        dialog.exec()

    def open_shortcut_manager_dialog(self):
        dialog = ShortcutManager(self)
        dialog.exec()

    def stop_execution(self):
        self.setWindowTitle(tr("APP_NAME"))

        if hasattr(self, "portal_process") and self.portal_process:
            if self.portal_process.poll() is None:
                try:
                    # Kill children of the process you started
                    parent = psutil.Process(self.portal_process.pid)
                    for child in parent.children(recursive=True):
                        try:
                            child.kill()
                            print(tr("STOP_PROCESS_SUCCESS", pid=child.pid))
                        except Exception as e:
                            print(tr("STOP_KILL_ERROR", pid=child.pid, error=e))

                    # Then kill the game process itself
                    self.portal_process.kill()
                    print(tr("STOP_PROCESS_SUCCESS", pid=self.portal_process.pid, exe=self.last_game))

                except Exception as e:
                    print(tr("STOP_KILL_ERROR", error=e))
            else:
                print(tr("STOP_NO_PROCESS_FOUND"))
        else:
            print(tr("STOP_NO_PORTAL_ACTIVE"))

        # Cleans internal references
        self.portal_process = None
        self.last_game = None
        self.real_portal_process = None

        # Unmount/eject mounted ISO, if present
        mount_point = meganimus_dir / "mounted_iso"

        if mount_point.exists():
            try:
                # Check if it is mounted
                result_check = subprocess.run(["mountpoint", "-q", str(mount_point)])
                if result_check.returncode == 0:
                    # Dismount with lazy unmount
                    result_unmount = subprocess.run(
                        ["fusermount", "-uz", str(mount_point)],
                        capture_output=True, text=True
                    )
                    if result_unmount.returncode != 0:
                        print(tr("ISO_UNMOUNT_FAILED", mount=str(mount_point), error=result_unmount.stderr.strip()))
                    else:
                        print(tr("ISO_UNMOUNTED", mount=str(mount_point)))
                else:
                    print(tr("ISO_NOT_MOUNTED", mount=str(mount_point)))

            except Exception as e:
                print(tr("ISO_UNMOUNT_EXCEPTION", error=str(e)))

            finally:
                # Remove the mounted_iso folder
                try:
                    shutil.rmtree(mount_point, ignore_errors=True)
                    print(tr("ISO_MOUNT_DIR_REMOVED", mount=str(mount_point)))
                except Exception as e:
                    print(tr("ISO_MOUNT_DIR_REMOVE_FAILED", mount=str(mount_point), error=str(e)))

    def kill_portal_process_on_exit(self):
        if hasattr(self, "portal_process") and self.portal_process and self.portal_process.poll() is None:
            print(tr("MEGANIMUS_CLOSED"))
            self.stop_execution()

    def setup_directories(self):
        """Creates the main Meganimus directory structure using pathlib with real folder names."""
        base = meganimus_dir
        subdirs = [
            base / "config",
            base / "art",
            base / "umu-prefix",
        ]

        for subdir in subdirs:
            subdir.mkdir(parents=True, exist_ok=True)

    def filter_portals(self, _=None):
        search_text = self.search_bar.text().lower()
        selected_executor = self.executor_filter.currentText()

        first_visible_item = None
        current_item = self.portal_list_widget.currentItem()

        for i in range(self.portal_list_widget.count()):
            item = self.portal_list_widget.item(i)
            name_match = search_text in item.text().lower()

            executor_name = item.data(Qt.ItemDataRole.UserRole + 1)
            executor_match = (selected_executor == tr("ALL_PORTALS")) or (executor_name == selected_executor)

            visible = name_match and executor_match
            item.setHidden(not visible)

            if visible and first_visible_item is None:
                first_visible_item = item

        if current_item is None or current_item.isHidden():
            if first_visible_item:
                self.portal_list_widget.setCurrentItem(first_visible_item)

    def load_portals(self):
        """Loads portal data from TOML files and populates the list, preserving the selection by TOML file."""

        # Save scroll position
        scroll_pos = self.portal_list_widget.verticalScrollBar().value()

        # Save which file was selected
        selected_portal_file = None
        current_item = self.portal_list_widget.currentItem()
        if current_item:
            selected_portal_file = current_item.data(Qt.ItemDataRole.UserRole)

        self.portal_list_widget.clear()

        if not meganimus_config_dir.exists():
            return

        portal_files = sorted(meganimus_config_dir.glob("portal-info-*.toml"))
        portals = []

        restored_selection_item = None
        for portal_file in portal_files:
            try:
                with open(portal_file, encoding="utf-8") as f:
                    portal_data = toml.load(f)

                portals.append((portal_data, portal_file))
                
                item = self.add_portal_to_list(portal_data)
                item.setData(Qt.ItemDataRole.UserRole, portal_file)

                if selected_portal_file and selected_portal_file == portal_file:
                    restored_selection_item = item
                    
            except (IOError, toml.TomlDecodeError) as e:
                print(tr("ERROR_LOADING_FILE", file=portal_file, error=e))

        # Restores the selection
        if restored_selection_item:
            self.portal_list_widget.setCurrentItem(restored_selection_item)
        else:
            if self.portal_list_widget.count() > 0:
                self.portal_list_widget.setCurrentRow(0)

        # Reapply the search filter
        if hasattr(self, "search_bar"):
            current_text = self.search_bar.text()
            self.filter_portals(current_text)

        # Restore scroll position and filter of the executor
        self.portal_list_widget.verticalScrollBar().setValue(scroll_pos)

        selected_executor_text = self.executor_filter.currentText()

        executors = ["AzaharPlus", "Cemu", "Dolphin", "Duckstation", "Eden", "Flycast", "Linux", "MelonDS", "mGBA", "PCSX2", "PPSSPP", "RPCS3", "Ryubing", "Snes9x", "UMU"]
        used_executors = set(portal_data.get("executor", "Linux") for portal_data, _ in portals)
        self.executor_filter.clear()
        self.executor_filter.addItem(tr("ALL_PORTALS"))
        for executor in executors:
            if executor in used_executors:
                self.executor_filter.addItem(executor)

        index_to_restore = self.executor_filter.findText(selected_executor_text)
        if index_to_restore != -1:
            self.executor_filter.setCurrentIndex(index_to_restore)
        else:
            self.executor_filter.setCurrentIndex(0)

    def add_portal(self):
        dialog = AddPortalDialog(self)
        dialog.portal_saved.connect(self.load_portals)
        dialog.exec()

    def edit_portal(self):
        portal_name = self.get_selected_portal()
        if not portal_name:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_PORTAL_SELECTED_ERROR"))
            return

        safe_portal_name = portal_name.replace(" ", "_").lower()
        portal_file_path = meganimus_config_dir / f"portal-info-{safe_portal_name}.toml"

        try:
            with portal_file_path.open('r', encoding='utf-8') as f:
                portal_data = toml.load(f)
        except (IOError, toml.TomlDecodeError):
            QMessageBox.critical(self, tr("APP_NAME"), tr("PORTAL_INFO_ERROR", name=portal_name))
            return

        dialog = AddPortalDialog(self, portal_data)
        dialog.portal_saved.connect(self.load_portals)
        dialog.exec()

    def start_portal(self, item_or_name):
        settings = load_settings()
        if self.windowTitle().startswith(tr("PORTAL_STARTED", portal_name="").split("{portal_name}")[0].strip()):
            reply = QMessageBox.question(
                self,
                tr("APP_NAME"),
                tr("PORTAL_ALREADY_ACTIVE"),
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )

            if reply == QMessageBox.StandardButton.Yes:
                self.stop_execution()
            else:
                return

        if not item_or_name:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_PORTAL_SELECTED_ERROR"))
            return

        portal_name = item_or_name.text() if isinstance(item_or_name, QListWidgetItem) else str(item_or_name)
        print(tr("STARTING_PORTAL", name=portal_name))

        safe_portal_name = portal_name.replace(" ", "_").lower()
        portal_file_path = meganimus_config_dir / f"portal-info-{safe_portal_name}.toml"

        try:
            with portal_file_path.open('r', encoding='utf-8') as f:
                portal_data = toml.load(f)
            print(tr("PORTAL_INFO_LOADED", name=portal_name))

            game_path_full = Path(portal_data['game_path'])
            executor = portal_data.get("executor", "Linux")

            executor_type = settings["executor"].get(f"{executor.lower()}_executor", "OFF")
            if executor != "Linux" and executor_type == "OFF":
                QMessageBox.warning(
                    None,
                    tr("APP_NAME"),
                    tr("EXECUTOR_NOT_CONFIGURED", executor=executor)
                )
                return

            # Check if the game path exists.
            if not game_path_full.exists():
                QMessageBox.critical(self, tr("APP_NAME"), tr("ERROR_GAME_NOT_FOUND", path=str(game_path_full)))
                return

            if executor == "RPCS3" and game_path_full.suffix.lower() == ".iso":

                iso_path = game_path_full
                mount_point = meganimus_dir / "mounted_iso"
                mount_point.mkdir(parents=True, exist_ok=True)

                # Check if it is already mounted
                result_check = subprocess.run(["mountpoint", "-q", str(mount_point)])
                if result_check.returncode != 0:
                    # Mount ISO using fuseiso
                    result_mount = subprocess.run(
                        ["fuseiso", str(iso_path), str(mount_point)],
                        capture_output=True, text=True
                    )
                    if result_mount.returncode != 0:
                        QMessageBox.critical(None, tr("APP_NAME"), tr("ISO_MOUNT_FAILED", error=result_mount.stderr))
                        return
                else:
                    print(tr("ISO_ALREADY_MOUNTED", mount=str(mount_point)))

                # Search for the PS3_GAME folder
                ps3_game_path = mount_point / "PS3_GAME"

                for _ in range(20):
                    if ps3_game_path.exists() and ps3_game_path.is_dir():
                        break
                    time.sleep(0.3)

                if not ps3_game_path.exists() or not ps3_game_path.is_dir():
                    QMessageBox.critical(None, tr("APP_NAME"), tr("PS3_GAME_FOLDER_NOT_FOUND_IN_ISO"))
                    return

                game_path_full = ps3_game_path

            # Initialize env with system copy
            env = os.environ.copy()

            # Language/Locale
            language = portal_data.get('language', '').strip()
            if language:
                try:
                    locale_code = language.split("(")[1].replace(")", "").strip() if "(" in language and ")" in language else language
                    env["LC_ALL"] = locale_code
                    env["LANG"] = locale_code
                    env["LANGUAGE"] = locale_code
                except Exception as e:
                    print(tr("LANGUAGE_SET_ERROR", error=e))

            # FPS HUDs
            show_fps = portal_data.get('show_fps', False)
            fps_hud_type = portal_data.get('fps_hud_type', '')
            if show_fps:
                if fps_hud_type == "FPS_GALLIUM_HUD":
                    env["GALLIUM_HUD"] = "fps+cpu,frametime"
                elif fps_hud_type == "FPS_DXVK_HUD":
                    env["DXVK_HUD"] = "fps,gpuload,frametimes"

            # Extra variables
            env_vars_str = portal_data.get('env_vars', '').strip()
            if env_vars_str:
                for item in env_vars_str.split():
                    if "=" in item:
                        key, value = item.split("=", 1)
                        env[key] = value

            # Set XDG_DATA_HOME to redirect UMU data to $HOME directory.
            if executor.lower() == "umu":
                env['XDG_DATA_HOME'] = str(home_dir)
                if 'WINEPREFIX' not in env:
                    env['WINEPREFIX'] = str(home_dir / 'AppsFiles' / 'Meganimus' / 'umu-prefix')

            # Gamemode
            use_gamemode = portal_data.get('use_gamemode', True)

            # Game arguments
            portal_args = portal_data.get('portal_args', '').strip()
            portal_args_list = portal_args.split() if portal_args else []

            def snap_exists(snap_name: str) -> bool:
                try:
                    subprocess.run(
                        ["snap", "list", snap_name],
                        check=True,
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
                    return True
                except subprocess.CalledProcessError:
                    return False

            def flatpak_exists(flatpak_name: str) -> bool:
                try:
                    subprocess.run(
                        ["flatpak", "info", flatpak_name],
                        check=True,
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
                    return True
                except subprocess.CalledProcessError:
                    return False

            def build_executor_command(executor, game_path):
                executor_type = settings["executor"].get(f"{executor.lower()}_executor", "OFF")
                executor_command_str = settings["executor"].get(f"{executor.lower()}_command", "").strip()
                executor_args_str = settings["executor"].get(f"{executor.lower()}_executor_args", "").strip()

                # Linux
                if executor == "Linux" or executor_type == "OFF":
                    return [str(game_path)]

                # Custom / AppImage
                if not executor_command_str:
                    if executor_type == "Custom":
                        QMessageBox.critical(None, tr("APP_NAME"), tr("EXECUTOR_COMMAND_NOT_SET"))
                    else:  # AppImage
                        QMessageBox.critical(None, tr("APP_NAME"), tr("EXECUTOR_PATH_NOT_SET"))
                    return None

                if executor_type == "AppImage":
                    executor_path = Path(executor_command_str)
                    if not executor_path.exists():
                        QMessageBox.critical(None, tr("APP_NAME"), tr("ERROR_EXECUTOR_APPIMAGE_NOT_FOUND", path=str(executor_path)))
                        return None
                    cmd = [str(executor_path)]
                else:
                    cmd = executor_command_str.split()

                # Check if the selected Snap or Flatpak exists.
                if executor_type == "Snap":
                    snap_name = executor_command_str.split()[2] if executor_command_str.startswith("snap run") else executor
                    if not snap_exists(snap_name):
                        QMessageBox.critical(None, tr("APP_NAME"), tr("ERROR_EXECUTOR_SNAP_NOT_FOUND", name=snap_name))
                        return None

                elif executor_type == "Flatpak":
                    flatpak_name = executor_command_str.split()[2] if executor_command_str.startswith("flatpak run") else executor
                    if not flatpak_exists(flatpak_name):
                        QMessageBox.critical(None, tr("APP_NAME"), tr("ERROR_EXECUTOR_FLATPAK_NOT_FOUND", name=flatpak_name))
                        return None

                if executor_args_str:
                    cmd += shlex.split(executor_args_str)

                cmd.append(str(game_path))
                return cmd

            executor_command = build_executor_command(executor, game_path_full)
            if executor_command is None:
                return

            # Gamemode in front, if enabled
            if use_gamemode and shutil.which("gamemoderun"):
                executor_command = [shutil.which("gamemoderun")] + executor_command

            # Final command
            command = executor_command + portal_args_list

            # For final command debugging
            debug_command = []
            for var in ["LC_ALL", "LANG", "LANGUAGE", "WINEPREFIX", "GALLIUM_HUD", "DXVK_HUD"]:
                if var in env:
                    debug_command.append(f"{var}={env[var]}")

            if env_vars_str:
                for item in env_vars_str.split():
                    if '=' in item:
                        debug_command.append(item)

            debug_command += executor_command + portal_args_list
            print(tr("RUNNING_COMMAND", command=" ".join(debug_command)))

            self.portal_process = subprocess.Popen(
                command,
                env=env,
                cwd=str(game_path_full.parent),
                stdout=sys.stdout,
                stderr=sys.stderr
            )

            self.last_game = str(game_path_full)
            self.setWindowTitle(tr("PORTAL_STARTED", portal_name=portal_name))

            # Short wait for spawn
            time.sleep(2)

            # Real process capture
            try:
                parent = psutil.Process(self.portal_process.pid)
                children = parent.children(recursive=True)
                self.real_portal_process = children[-1] if children else None
                if self.real_portal_process:
                    print(tr("DEBUG_REAL_PORTAL_INITIATED", pid=self.real_portal_process.pid))
            except psutil.NoSuchProcess:
                self.real_portal_process = None

        except (IOError, toml.TomlDecodeError):
            QMessageBox.critical(self, tr("APP_NAME"), tr("PORTAL_INFO_ERROR", name=portal_name))
        except Exception as e:
            QMessageBox.critical(self, tr("APP_NAME"), tr("PORTAL_START_ERROR", error=str(e)))

    def start_executor(self, executor_name, executor_type=None, executor_command_str=None):
        settings = load_settings()
        if self.windowTitle().startswith(tr("PORTAL_STARTED", portal_name="").split("{portal_name}")[0].strip()):
            reply = QMessageBox.question(
                self,
                tr("APP_NAME"),
                tr("PORTAL_ALREADY_ACTIVE"),
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )

            if reply == QMessageBox.StandardButton.Yes:
                self.stop_execution()
            else:
                return

        if executor_type is None:
            executor_type = settings["executor"].get(f"{executor_name.lower()}_executor", "OFF")
        if executor_command_str is None:
            executor_command_str = settings["executor"].get(f"{executor_name.lower()}_command", "").strip()

        print(tr("STARTING_PORTAL", name=executor_name))

        if executor_type == "OFF" or not executor_type:
            QMessageBox.warning(
                None,
                tr("APP_NAME"),
                tr("EXECUTOR_VERSION_NOT_SELECTED", executor=executor_name)
            )
            return

        # Custom / AppImage
        if executor_type in ("Custom", "AppImage"):
            if not executor_command_str:
                if executor_type == "Custom":
                    QMessageBox.critical(None, tr("APP_NAME"), tr("EXECUTOR_COMMAND_NOT_SET"))
                else:  # AppImage
                    QMessageBox.critical(None, tr("APP_NAME"), tr("EXECUTOR_PATH_NOT_SET"))
                return None

            if executor_type == "AppImage":
                executor_path = Path(executor_command_str)
                if not executor_path.exists():
                    QMessageBox.critical(None, tr("APP_NAME"), tr("ERROR_EXECUTOR_APPIMAGE_NOT_FOUND", path=str(executor_path)))
                    return None
                command = [str(executor_path)]
            else:  # Custom
                command = executor_command_str.split()

        elif executor_type == "Snap":
            snap_name = executor_command_str.split()[2] if executor_command_str.startswith("snap run") else executor_name
            try:
                subprocess.run(["snap", "list", snap_name], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            except subprocess.CalledProcessError:
                QMessageBox.critical(None, tr("APP_NAME"), tr("ERROR_EXECUTOR_SNAP_NOT_FOUND", name=snap_name))
                return
            command = executor_command_str.split()

        elif executor_type == "Flatpak":
            flatpak_name = executor_command_str.split()[2] if executor_command_str.startswith("flatpak run") else executor_name
            try:
                subprocess.run(["flatpak", "info", flatpak_name], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            except subprocess.CalledProcessError:
                QMessageBox.critical(None, tr("APP_NAME"), tr("ERROR_EXECUTOR_FLATPAK_NOT_FOUND", name=flatpak_name))
                return
            command = executor_command_str.split()

        else:
            command = [executor_name]

        env = os.environ.copy()
        debug_command = command.copy()
        print(tr("RUNNING_COMMAND", command=" ".join(debug_command)))

        try:
            self.portal_process = subprocess.Popen(
                command,
                env=env,
                cwd=str(Path.home()),
                stdout=sys.stdout,
                stderr=sys.stderr
            )
            self.setWindowTitle(tr("PORTAL_STARTED", portal_name=executor_name))
        except Exception as e:
            QMessageBox.critical(None, tr("APP_NAME"), f"{tr("FAILED_TO_START")}: {e}")
            return

        time.sleep(2)
        try:
            parent = psutil.Process(self.portal_process.pid)
            children = parent.children(recursive=True)
            self.real_portal_process = children[-1] if children else None
            if self.real_portal_process:
                print(tr("DEBUG_REAL_PORTAL_INITIATED", pid=self.real_portal_process.pid))
        except psutil.NoSuchProcess:
            self.real_portal_process = None

    def start_selected_portal(self):
        portal_name = self.get_selected_portal()
        if not portal_name:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_PORTAL_SELECTED_ERROR"))
            return

        self.start_portal(portal_name)

    def get_selected_portal(self):
        item = self.portal_list_widget.currentItem()
        if item:
            return item.text()
        return None

    def add_portal_to_list(self, portal_data):
        portal_name = portal_data['name']
        executor_name = portal_data.get("executor", "Linux")

        item = QListWidgetItem()
        item.setText(portal_name)
        item.setData(Qt.ItemDataRole.UserRole + 1, executor_name)

        # Bold
        font = item.font()
        font.setBold(True)
        item.setFont(font)

        # Decide which image to use
        art_path_to_use = None
        layout_mode = settings.get("layout_mode", "classic")

        art_path_to_use = portal_data.get("art_path")

        # Art as an icon
        icon = None
        if art_path_to_use:
            art_file = Path(art_path_to_use)
            if art_file.exists():
                pixmap = QPixmap(str(art_file))
                if not pixmap.isNull():
                    pixmap = pixmap.scaled(
                        self.portal_list_widget.iconSize(),
                        Qt.AspectRatioMode.KeepAspectRatio,
                        Qt.TransformationMode.SmoothTransformation
                    )
                    icon = QIcon()
                    icon.addPixmap(pixmap, QIcon.Mode.Normal, QIcon.State.Off)
                    icon.addPixmap(pixmap, QIcon.Mode.Selected, QIcon.State.Off)
                    icon.addPixmap(pixmap, QIcon.Mode.Active, QIcon.State.Off)
                    icon.addPixmap(pixmap, QIcon.Mode.Disabled, QIcon.State.Off)

        if icon is None:
            icon = self.windowIcon()

        if layout_mode not in ["list"] and icon is not None:
            item.setIcon(icon)

        self.portal_list_widget.addItem(item)
        return item

    def open_transfer_arts(self):
        dialog = SteamGridDBApp(self)
        dialog.parent_ref = self
        dialog.exec()

    def open_settings(self):
        dlg = SettingsDialog(self)
        dlg.exec()

    def show_about(self):
        dialog = QDialog(self)
        dialog.setWindowTitle(tr("ABOUT_MEGANIMUS"))
        dialog.setWindowModality(Qt.WindowModality.ApplicationModal)

        layout = QVBoxLayout(dialog)

        # Meganimus icon
        icon = self.windowIcon()
        if not icon.isNull():
            icon_label = QLabel()
            icon_label.setPixmap(icon.pixmap(64, 64))
            icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            layout.addWidget(icon_label)

        # About text
        label = QLabel(tr("ABOUT_TEXT_HTML"))
        label.setWordWrap(True)
        label.setTextFormat(Qt.TextFormat.RichText)
        label.setOpenExternalLinks(True)
        label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(label)

        # Update button
        update_button = QPushButton(tr("CHECK_UPDATE_BUTTON"))
        update_button.clicked.connect(self.check_update)
        layout.addWidget(update_button, alignment=Qt.AlignmentFlag.AlignCenter)

        dialog.exec()

    def check_update(self):
        try:
            response = requests.get("https://api.github.com/repos/Kyuyrii/Meganimus/tags", timeout=5)
            response.raise_for_status()
            tags = response.json()
            if not tags:
                QMessageBox.warning(self, tr("APP_NAME"), tr("NO_TAGS_FOUND"))
                return

            latest_tag = tags[0]["name"].lstrip("v")
            current_version = __version__

            def version_tuple(v):
                return tuple(int(x) for x in v.split("."))

            if version_tuple(current_version) >= version_tuple(latest_tag):
                QMessageBox.information(self, tr("APP_NAME"), tr("ALREADY_UPDATED"))
            else:
                reply = QMessageBox.question(
                    self,
                    tr("APP_NAME"),
                    tr("NEW_VERSION_AVAILABLE", version=latest_tag),
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                )
                if reply == QMessageBox.StandardButton.Yes:
                    subprocess.Popen(['xdg-open', 'https://github.com/Kyuyrii/Meganimus/releases'])
        except Exception as e:
            QMessageBox.warning(self, tr("APP_NAME"), tr("UPDATE_ERROR", error=e))

# Heroes and icons images / SteamGridDB
HEROES_DIR = meganimus_dir / "sgdb" / "heroes"
ICONS_DIR = meganimus_dir / "sgdb" / "icons"
HEROES_DIR.mkdir(parents=True, exist_ok=True)
ICONS_DIR.mkdir(parents=True, exist_ok=True)

# ===================== SGDB: artwork worker (thread) =====================
class ArtworkLoader(QThread):
    finished = pyqtSignal(list)  # List of artworks [{id, url, img_data}, ...]
    error = pyqtSignal(str)
    progress = pyqtSignal(int)   # 0 to 100%

    def __init__(self, api_key, game_id, art_type="heroes"):
        super().__init__()
        self.api_key = api_key
        self.game_id = game_id
        self.art_type = art_type  # "heroes" or "icons"

    def run(self):
        try:
            headers = {"Authorization": f"Bearer {self.api_key}"}
            url = f"https://www.steamgriddb.com/api/v2/{self.art_type}/game/{self.game_id}"
            resp = requests.get(url, headers=headers, timeout=20)
            resp.raise_for_status()
            data = resp.json().get("data", [])

            results = []
            total = len(data)

            for idx, art in enumerate(data):
                # Attempt to find the best available URL, in descending order of priority
                img_url = (
                    art.get("thumb")
                    or art.get("thumb_url")
                    or (art.get("thumbs")[0] if isinstance(art.get("thumbs"), list) and art.get("thumbs") else None)
                    or art.get("full")
                    or art.get("url")
                )

                img_data = None
                if img_url:
                    try:
                        rt = requests.get(img_url, timeout=15)
                        rt.raise_for_status()
                        img_data = rt.content
                    except Exception:
                        img_data = None  # If it fails, continue

                results.append({
                    "id": art.get("id"),
                    "url": img_url,
                    "img_data": img_data
                })

                # Updates the progress bar
                if total > 0:
                    self.progress.emit(int((idx + 1) / total * 100))

            self.finished.emit(results)

        except Exception as e:
            self.error.emit(tr("ARTS_LOAD_ERROR", error=str(e)))

# ===================== SGDB: Transfer heroes window =====================
class SteamGridDBApp(QDialog):
    def __init__(self, parent):
        super().__init__(parent)
        self.api_key = None
        self.headers = None
        self.results = []
        self.heroes = []
        self.selected_game = None
        self._cancel_auto = False

        self.setWindowTitle(tr("TRANSFER_ARTS_TITLE"))
        self.resize(750, 480)
        self.setMinimumSize(300, 250)

        main_layout = QVBoxLayout(self)
        self.setLayout(main_layout)

        # Lists (results and images) with resizable splitter
        self.games_panel = self.make_radio_panel_for_games()

        # Image Container Using QScrollArea
        self.images_container = QWidget()
        self.images_layout = QVBoxLayout(self.images_container)
        self.images_layout.setContentsMargins(6, 6, 6, 6)
        self.images_layout.setSpacing(4)
        self.images_layout.setAlignment(Qt.AlignmentFlag.AlignTop)  # Force items to the top

        self.images_scroll = QScrollArea()
        self.images_scroll.setWidgetResizable(True)
        self.images_scroll.setWidget(self.images_container)

        # Creates horizontal splitter
        body_splitter = QSplitter(Qt.Orientation.Horizontal)
        body_splitter.addWidget(self.games_panel["scroll"])
        body_splitter.addWidget(self.images_scroll)

        # Equal initial width for both sides
        body_splitter.setSizes([1, 1])

        # Prevents any side from disappearing when dragging
        body_splitter.setChildrenCollapsible(False)

        # Adds to main layout
        main_layout.addWidget(body_splitter)

        # Search
        search_row = QHBoxLayout()

        self.auto_button = QPushButton(tr("AUTO_TRANSFER_BUTTON"))
        self.auto_button.clicked.connect(self.run_auto_transfer)
        search_row.addWidget(self.auto_button)

        self.search_input = QLineEdit()
        search_row.addWidget(self.search_input)

        search_btn = QPushButton(tr("SEARCH"))
        search_btn.clicked.connect(self.search_game)
        search_row.addWidget(search_btn)
        main_layout.addLayout(search_row)

        # Action buttons (3 side by side)
        buttons_row = QHBoxLayout()

        self.load_icons_button = QPushButton(tr("LOAD_ICONS"))
        self.load_icons_button.setEnabled(False)
        self.load_icons_button.clicked.connect(partial(self.load_artwork, "icons"))
        buttons_row.addWidget(self.load_icons_button)

        self.transfer_button = QPushButton(tr("TRANSFER"))
        self.transfer_button.setEnabled(False)
        self.transfer_button.clicked.connect(self.transfer_images)
        self.transfer_button.setAutoDefault(False)
        self.transfer_button.setDefault(False)
        buttons_row.addWidget(self.transfer_button)

        self.load_heroes_button = QPushButton(tr("LOAD_HEROES"))
        self.load_heroes_button.setEnabled(False)
        self.load_heroes_button.clicked.connect(partial(self.load_artwork, "heroes"))
        buttons_row.addWidget(self.load_heroes_button)

        main_layout.addLayout(buttons_row)

        # Progress bar always visible
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)  # Starts at 0%
        main_layout.addWidget(self.progress_bar)

        # Load API key if it exists
        self.load_api_key()

    def closeEvent(self, event):
        self._cancel_auto = True
        event.accept()

    def run_auto_transfer(self):
        self._cancel_auto = False

        def get_score(item):
            return item.get("score", 0)

        if not self.headers:
            QMessageBox.warning(self, tr("APP_NAME"), tr("API_KEY_SAVE_FIRST"))
            return

        if not any(meganimus_config_dir.glob("portal-info-*.toml")):
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_PORTALS_FOUND"))
            return

        # Portals list
        portals = []
        for toml_file in meganimus_config_dir.glob("portal-info-*.toml"):
            try:
                with open(toml_file, "r", encoding="utf-8") as fh:
                    inv = toml.load(fh)
                inv_name = inv.get("name") or inv.get("display_name") or inv.get("id")
                art_path = inv.get("art_path", "")
                gui_path = inv.get("gui_path", "")
                # Also includes cases where paths are filled in but the files do not exist
                art_missing = not art_path or not Path(art_path).exists()
                gui_missing = not gui_path or not Path(gui_path).exists()
                if inv_name and (art_missing or gui_missing):
                    portals.append((inv_name, toml_file))
            except Exception:
                continue

        if not portals:
            QMessageBox.information(self, tr("APP_NAME"), tr("AUTO_TRANSFER_NO_MISSING_ARTS"))
            return

        confirm = QMessageBox.question(
            self,
            tr("APP_NAME"),
            tr("AUTO_TRANSFER_EXPLAIN"),
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        if confirm != QMessageBox.StandardButton.Yes:
            return

        # Progress bar
        total = len(portals)
        self.progress_bar.setRange(0, total)
        self.progress_bar.setValue(0)
        self.setEnabled(False)
        QApplication.processEvents()

        # Directories
        ART_DIR = meganimus_dir / "art"
        GUI_DIR = meganimus_dir / "art" / "gui"
        ART_DIR.mkdir(parents=True, exist_ok=True)
        GUI_DIR.mkdir(parents=True, exist_ok=True)

        completed = 0
        downloads = []  # Stores the hero and icon paths before copying

        for inv_name, toml_file in portals:
            if self._cancel_auto:
                break

            hero_saved_path = None
            icon_saved_path = None

            try:
                # Search on SteamGridDB
                search_url = f"https://www.steamgriddb.com/api/v2/search/autocomplete/{inv_name}"
                resp = requests.get(search_url, headers=self.headers, timeout=15)
                resp.raise_for_status()
                data = resp.json().get("data", [])
                if not data:
                    completed += 1
                    self.progress_bar.setValue(completed)
                    QApplication.processEvents()
                    continue

                game = data[0]
                game_id = game.get("id")
                steam_game_name = game.get("name") or str(game_id)

                # Download the hero
                try:
                    hero_url = f"https://www.steamgriddb.com/api/v2/heroes/game/{game_id}"
                    r = requests.get(hero_url, headers=self.headers, timeout=20)
                    r.raise_for_status()
                    heroes = r.json().get("data", []) or []
                except Exception:
                    heroes = []

                if heroes:
                    heroes.sort(key=get_score, reverse=True)
                    best = heroes[0]
                    img_url = (
                        best.get("thumb")
                        or best.get("thumb_url")
                        or (best.get("thumbs")[0] if isinstance(best.get("thumbs"), list) and best.get("thumbs") else None)
                        or best.get("full")
                        or best.get("url")
                    )
                    if img_url:
                        try:
                            rr = requests.get(img_url, timeout=20)
                            rr.raise_for_status()
                            ext = Path(img_url).suffix
                            if not ext or len(ext) > 6:
                                ext = ".png"
                            game_hero_dir = HEROES_DIR / steam_game_name
                            game_hero_dir.mkdir(parents=True, exist_ok=True)
                            hero_filename = game_hero_dir / f"hero_{best.get('id')}{ext}"
                            with hero_filename.open("wb") as fh:
                                fh.write(rr.content)
                            hero_saved_path = hero_filename
                        except Exception:
                            hero_saved_path = None

                # Download the icon
                try:
                    icon_url = f"https://www.steamgriddb.com/api/v2/icons/game/{game_id}"
                    r = requests.get(icon_url, headers=self.headers, timeout=20)
                    r.raise_for_status()
                    icons = r.json().get("data", []) or []
                except Exception:
                    icons = []

                if icons:
                    icons.sort(key=get_score, reverse=True)
                    best = icons[0]
                    img_url = (
                        best.get("thumb")
                        or best.get("thumb_url")
                        or (best.get("thumbs")[0] if isinstance(best.get("thumbs"), list) and best.get("thumbs") else None)
                        or best.get("full")
                        or best.get("url")
                    )
                    if img_url:
                        try:
                            rr = requests.get(img_url, timeout=20)
                            rr.raise_for_status()
                            ext = Path(img_url).suffix
                            if not ext or len(ext) > 6:
                                ext = ".png"
                            game_icon_dir = ICONS_DIR / steam_game_name
                            game_icon_dir.mkdir(parents=True, exist_ok=True)
                            icon_filename = game_icon_dir / f"icon_{best.get('id')}{ext}"
                            with icon_filename.open("wb") as fh:
                                fh.write(rr.content)
                            icon_saved_path = icon_filename
                        except Exception:
                            icon_saved_path = None

                # Store for later copying
                downloads.append((inv_name, toml_file, hero_saved_path, icon_saved_path))

            except Exception as e:
                print(tr("AUTO_TRANSFER_GENERAL_ERROR", inv_name=inv_name, error=str(e)))
            finally:
                completed += 1
                self.progress_bar.setValue(completed)
                QApplication.processEvents()

        # After all downloads are complete, copy to art/gui
        if not self._cancel_auto:
            for inv_name, toml_file, hero_saved_path, icon_saved_path in downloads:
                normalized = inv_name.lower().replace(" ", "_").replace("/", "_").replace("\\", "_")
                copied_hero = False
                copied_icon = False

                try:
                    with open(toml_file, "r", encoding="utf-8") as fh:
                        inv_toml = toml.load(fh)
                except Exception:
                    inv_toml = {}

                if hero_saved_path:
                    try:
                        dest = ART_DIR / f"{normalized}{hero_saved_path.suffix}"
                        shutil.copy2(hero_saved_path, dest)
                        inv_toml["art_path"] = str(dest)
                        copied_hero = True
                    except Exception:
                        copied_hero = False

                if icon_saved_path:
                    try:
                        dest_icon = GUI_DIR / f"{normalized}{icon_saved_path.suffix}"
                        shutil.copy2(icon_saved_path, dest_icon)
                        inv_toml["gui_path"] = str(dest_icon)
                        copied_icon = True
                    except Exception:
                        copied_icon = False

                if copied_hero or copied_icon:
                    try:
                        with open(toml_file, "w", encoding="utf-8") as fh:
                            toml.dump(inv_toml, fh)
                    except Exception:
                        pass

        # Finalize progress bar
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(100)
        self.setEnabled(True)

        if not self._cancel_auto:
            if hasattr(self, 'parent_ref') and self.parent_ref:
                self.parent_ref.load_portals()
            QMessageBox.information(self, tr("APP_NAME"), tr("AUTO_TRANSFER_FINISHED"))

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Prevents Enter from triggering something that is not selected
            return
        super().keyPressEvent(event)

    def load_api_key(self):
        settings = load_settings()
        self.api_key = settings["other"].get("sgdb_apikey", "").strip()
        self.headers = {"Authorization": f"Bearer {self.api_key}"} if self.api_key else None

    # Search games
    def search_game(self):
        """Searches for games in SteamGridDB and updates the radio panel."""
        if not self.headers:
            QMessageBox.warning(self, tr("APP_NAME"), tr("API_KEY_SAVE_FIRST"))
            return

        term = self.search_input.text().strip()
        if not term:
            QMessageBox.warning(self, tr("APP_NAME"), tr("ENTER_GAME_NAME"))
            return

        # Clear selection and UI before fetching
        self.selected_game = None
        # Clear the image container
        for i in reversed(range(self.images_layout.count())):
            widget = self.images_layout.itemAt(i).widget()
            if widget:
                widget.setParent(None)
        self.transfer_button.setEnabled(False)
        self.clear_radio_panel(self.games_panel)

        # API Search
        try:
            url = f"https://www.steamgriddb.com/api/v2/search/autocomplete/{term}"
            resp = requests.get(url, headers=self.headers, timeout=20)
            resp.raise_for_status()
            data = resp.json()
            self.results = data.get("data", []) if isinstance(data, dict) else []
        except Exception as e:
            QMessageBox.critical(self, tr("APP_NAME"), tr("API_FAIL", error=str(e)))
            return

        layout = self.games_panel["layout"]
        group = self.games_panel["button_group"]

        # No results
        if not self.results:
            layout.addWidget(QLabel(tr("NO_RESULTS")))
            return

        # Create new radios
        for game in self.results:
            rb = QRadioButton(f"{game.get('id')} - {game.get('name')}")
            rb.setProperty("game_data", game)
            rb.toggled.connect(self.on_game_radio_toggled)
            group.addButton(rb)
            layout.addWidget(rb)

    def clear_radio_panel(self, panel: dict):
        """Removes all radios and widgets from a radio panel."""
        group = panel["button_group"]
        layout = panel["layout"]

        # Remove buttons from group
        for btn in group.buttons():
            group.removeButton(btn)
            btn.deleteLater()

        # Remove widgets from the layout
        while layout.count():
            item = layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

    def make_radio_panel_for_games(self):
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)

        container = QWidget()
        layout = QVBoxLayout(container)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(4)
        scroll.setWidget(container)

        group = QButtonGroup(self)
        group.setExclusive(True)

        return {
            "scroll": scroll,
            "container": container,
            "layout": layout,
            "button_group": group,
        }

    def on_game_radio_toggled(self, checked: bool):
        if not checked:
            return
        rb = self.sender()
        game = rb.property("game_data")
        if not game:
            return
        self.selected_game = game

        # Activate the upload buttons
        self.load_icons_button.setEnabled(True)
        self.load_heroes_button.setEnabled(True)

    def load_artwork(self, art_type: str):
        """Loads artwork (heroes or icons) via worker."""
        if not self.selected_game:
            return

        game_id = self.selected_game.get("id")
        if not game_id:
            return

        self.current_art_type = art_type

        self.setEnabled(False)
        # Clear previous images
        for i in reversed(range(self.images_layout.count())):
            widget = self.images_layout.itemAt(i).widget()
            if widget:
                widget.setParent(None)
        self.transfer_button.setEnabled(False)

        # Infinite progress bar while loading
        self.progress_bar.setRange(0, 0)

        self.loader = ArtworkLoader(self.api_key, game_id, art_type)
        self.loader.finished.connect(self.on_images_loaded)
        self.loader.error.connect(self.on_loader_error)
        self.loader.start()

    def on_loader_error(self, msg):
        self.setEnabled(True)
        # Reset the bar
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        QMessageBox.critical(self, tr("APP_NAME"), msg)

    def on_images_loaded(self, heroes):
        self.setEnabled(True)

        # Reset progress bar
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)

        self.heroes = heroes or []

        # Clear image container
        for i in reversed(range(self.images_layout.count())):
            widget = self.images_layout.itemAt(i).widget()
            if widget:
                widget.setParent(None)

        if not self.heroes:
            label = QLabel(tr("NO_IMAGES"))
            self.images_layout.addWidget(label)
            self.transfer_button.setEnabled(False)
            return

        for hero in self.heroes:
            row = QWidget()
            row_layout = QHBoxLayout(row)
            row_layout.setContentsMargins(0, 0, 0, 0)
            # Adjust spacing according to the current Qt style
            if QApplication.style().objectName().lower() == "oxygen":
                row_layout.setSpacing(0)  # Specific Spacing for Oxygen
            else:
                row_layout.setSpacing(8)  # Default Spacing

            # Checkbox on the left
            checkbox = QCheckBox()
            checkbox.setProperty("hero_data", hero)
            row_layout.addWidget(checkbox)

            # Image
            img_label = QLabel()
            if img_data := hero.get("img_data"):
                pixmap = QPixmap()
                pixmap.loadFromData(img_data)
                img_label.setPixmap(pixmap.scaled(
                    240, 108,
                    Qt.AspectRatioMode.KeepAspectRatio,
                    Qt.TransformationMode.SmoothTransformation
                ))
            row_layout.addWidget(img_label)

            # Name/ID next to image
            text_label = QLabel(f"ID {hero.get('id')}")
            text_label.setContentsMargins(8, 0, 0, 0)
            row_layout.addWidget(text_label)

            row_layout.addStretch()  # Maintains clean horizontal alignment

            self.images_layout.addWidget(row)

        self.transfer_button.setEnabled(True)

    def transfer_images(self):
        """Transfers the selected images."""
        if not self.selected_game:
            return

        to_transfer = []

        for i in range(self.images_layout.count()):
            row = self.images_layout.itemAt(i).widget()
            if not row:
                continue
            checkbox = row.findChild(QCheckBox)
            if checkbox and checkbox.isChecked():
                hero = checkbox.property("hero_data")
                if hero and hero.get("url"):
                    to_transfer.append(hero)

        if not to_transfer:
            QMessageBox.information(self, tr("APP_NAME"), tr("SELECT_AT_LEAST_ONE_IMAGE"))
            return

        self.setEnabled(False)

        game_name = (self.selected_game.get("name") or str(self.selected_game.get('id'))).replace("/", "_")
        base_dir = HEROES_DIR if self.current_art_type == "heroes" else ICONS_DIR
        save_dir = base_dir / game_name
        save_dir.mkdir(parents=True, exist_ok=True)

        # Pull-up bar
        self.progress_bar.setRange(0, len(to_transfer))
        self.progress_bar.setValue(0)

        for i, art in enumerate(to_transfer, start=1):
            url = art.get("url")
            try:
                r = requests.get(url, timeout=30)
                r.raise_for_status()
                ext = Path(url).suffix
                if not ext or len(ext) > 6:
                    ext = ".png"
                prefix = "hero_" if self.current_art_type == "heroes" else "icon_"
                filename = save_dir / f"{prefix}{art.get('id')}{ext}"
                with filename.open("wb") as f:
                    f.write(r.content)
            except Exception as e:
                print(tr("ERROR_TRANSFERRING_URL", url=url, error=e))

            self.progress_bar.setValue(i)
            QApplication.processEvents()

        # Reset bar
        self.progress_bar.setValue(100)
        QMessageBox.information(self, tr("APP_NAME"), tr("TRANSFER_SUMMARY", len=len(to_transfer), dir=str(save_dir)))
        self.setEnabled(True)
        self.progress_bar.setValue(0)

if __name__ == "__main__":
    # Loads settings
    settings = load_settings()
    # Uses full saved locale, or LANG defined in the module (which already has 'pt_BR.UTF-8', for example)
    current_lang = settings["design"].get("language", LANG)
    LANG = current_lang  # Update the global variable
    app = QApplication(sys.argv)

    # Load Qt translation
    translator = QTranslator()
    user_locale = LANG
    translations_path = QLibraryInfo.path(QLibraryInfo.LibraryPath.TranslationsPath)

    if translator.load(f"qt_{user_locale}", translations_path):
        app.installTranslator(translator)

    # Define the application ID so Wayland can find the icon.
    # We use the lowercase application name with hyphens instead of spaces.
    app_id = tr("APP_NAME").lower().replace(' ', '-')
    app.setDesktopFileName(app_id)

    # Helper function to send command to already running instance
    def send_to_running_instance(message: str) -> bool:
        socket = QLocalSocket()
        socket.connectToServer("meganimus_single_instance")
        if socket.waitForConnected(300):
            socket.write(message.encode("utf-8"))
            socket.flush()
            socket.waitForBytesWritten(300)
            socket.disconnectFromServer()
            return True
        return False

    # Try sending --start-portal command to existing instance
    if "--start-portal" in sys.argv:
        try:
            idx = sys.argv.index("--start-portal") + 1
            portal_name = sys.argv[idx]
            if send_to_running_instance(f'--start-portal "{portal_name}"'):
                sys.exit(0)
        except IndexError:
            pass

    # Server for single instance
    def handle_new_connection():
        socket = window.server.nextPendingConnection()
        if not socket.waitForReadyRead(1000):
            socket.disconnectFromServer()
            return
        data = socket.readAll().data().decode("utf-8").strip()

        if data == "--heartbeat":
            socket.write(b"alive")
            socket.flush()
            socket.waitForBytesWritten(300)
            socket.disconnectFromServer()
            return

        if data.startswith("--start-portal "):
            portal_name = data[len("--start-portal "):].strip('"')
            QTimer.singleShot(200, partial(window.start_portal, portal_name))

        socket.disconnectFromServer()

    def is_instance_alive() -> bool:
        socket = QLocalSocket()
        socket.connectToServer("meganimus_single_instance")
        if socket.waitForConnected(300):
            socket.write(b"--heartbeat")
            socket.flush()
            if socket.waitForReadyRead(300):
                response = socket.readAll().data().decode("utf-8").strip()
                socket.disconnectFromServer()
                if response == "alive":
                    return True
        QLocalServer.removeServer("meganimus_single_instance")
        return False

    # If another instance is already running, send the command to it and exit
    if is_instance_alive():
        if "--start-portal" in sys.argv:
            try:
                idx = sys.argv.index("--start-portal") + 1
                portal_name = sys.argv[idx]
                send_to_running_instance(f'--start-portal "{portal_name}"')
            except IndexError:
                pass
        sys.exit(0)

    window = Meganimus()

    window.server_name = "meganimus_single_instance"
    window.server = QLocalServer(window)
    window.server.listen(window.server_name)
    window.server.newConnection.connect(handle_new_connection)

    if "--start-portal" in sys.argv:
        try:
            idx = sys.argv.index("--start-portal") + 1
            portal_name = sys.argv[idx]
            QTimer.singleShot(500, partial(window.start_portal, portal_name))
        except IndexError:
            pass

    sys.exit(app.exec())
