#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

import sys
import os
import locale
import json
import subprocess
import atexit
import shutil
import requests
import tarfile
import io
import threading
import time
import psutil
import uuid
from pathlib import Path

# Translation System
try:
    locale.setlocale(locale.LC_ALL, '')
    LANG, _ = locale.getlocale(locale.LC_CTYPE)
except locale.Error:
    LANG = 'en_US'

if not LANG:
    LANG = 'en_US'

# Supported languages
SUPPORTED_LANGUAGES = {
    "English": "en_US",
    "Português": "pt_BR",
}

__version__ = "0.1"
__creator__ = "<a href='https://github.com/Kyuyrii'>Kyuyrii</a>"

TRANSLATIONS = {
    'en_US': {
        "ABOUT_TEXT_HTML": f"""<b>Meganimus</b><br>
        Version: {__version__}<br><br>
        A launcher to centralize your native Linux and emulator games.<br>
        License: <a href='https://www.gnu.org/licenses/gpl-3.0.html.en'>GPLv3</a><br>
        Created by {__creator__}""",
        "ABOUT_MEGANIMUS": "About Meganimus",
        "ABOUT_ZORDEER": "About Zordeer",
        "ADD_FILES": "Add files",
        "API_FAIL": "API error:\n{e}",
        "API_KEY_REQUIRED_SGDB": "Please enter your SteamGridDB API key.",
        "API_KEY_SAVED": "API key saved",
        "API_KEY_SAVE_ERROR": "Could not save key:\n{e}",
        "API_KEY_SAVE_FIRST": "Save your API key first.",
        "APP_NAME": "Meganimus",
        "BROWSE_BUTTON": "Browse",
        "CANCEL_BUTTON": "Cancel",
        "CLEAR_LIST": "Clear list",
        "CONFIRM_CLOSE_MESSAGE": "Do you want to end the current portal and close Meganimus?",
        "CONFIRM_REMOVE": "Remove '{name}'?",
        "MULTIPLE_PORTAL_CREATOR": "Multiple portal creator",
        "CREATE_PORTAL": "Create portal",
        "DEBUG_REAL_PORTAL_INITIATED": "[DEBUG] portal initiated as PID {pid}",
        "DEBUG_TEMP_FILE_REMOVED": "[DEBUG] Temporary file removed: {path}",
        "DELETE_PORTAL_CONFIRM_MESSAGE": "Are you sure you want to remove the portal '{name}'?",
        "DELETE_PORTALS_CONFIRM_MESSAGE": "Are you sure you want to remove the selected portals?",
        "DONE": "Done",
        "DUPLICATE_NAME_IN_LIST": "There is already another portal in the list with the name: {name}",
        "ENTER_GAME_NAME": "Enter a game name.",
        "ENVIRONMENT_VARS": "Variables:",
        "ERROR": "Error",
        "ERROR_LOADING_FILE": "Error loading file {file}: {error}",
        "ERROR_REMOVING_FILE": "Error removing {file}: {error}",
        "ERROR_TRANSFERRING_URL": "Error transferring {url}: {error}",
        "EXECUTORS": "Executors:",
        "EXECUTOR_COMMAND": "Command:",
        "EXECUTOR_VERSION": "Version:",
        "EXTRAS": "Extras",
        "EXTRACTING": "Extracting: {name}",
        "GAME_FILE_FILTER": "All Files (*)",
        "GAME_PATH": "Game:",
        "FAILED_UPDATE_JSON": "Could not update portal information: {error}",
        "FILE": "File",
        "FOLDER": "Folder",
        "FPS_GALLIUM_HUD": "Gallium HUD (Not always compatible)",
        "GAMEMODE": "Use Feral gamemode",
        "HEROES_LOAD_ERROR": "[DEBUG] Failed to load heroes: {error}",
        "HIDE_PORTAL_IMAGES": "Hide images from the list",
        "IMAGE_FILTER": "Image Files (*.jpg *.jpeg *.png *.webp);;All Files (*)",
        "PORTAL": "Portal",
        "PORTAL_ALREADY_ACTIVE": "Close current portal and start the selected one?",
        "PORTAL_ALREADY_EXISTS": "There is already an portal with that name. Choose another.",
        "PORTAL_ARGS": "Arguments:",
        "PORTAL_ART_PATH": "Art:",
        "PORTAL_INFO_ERROR": "Unable to access/execute the game or find information about this portal.",
        "PORTAL_INFO_LOADED": "portal info loaded successfully for: {name}",
        "PORTAL_LANGUAGE": "Language (Locale):",
        "PORTAL_NAME": "Name:",
        "PORTAL_IN_MULTIPLE_CREATE_ALREADY_EXISTS": "The portal '{name}' already exists, use another name.",
        "PORTAL_START_ERROR": "An error occurred while trying to start the portal: {error}",
        "PORTAL_STARTED": "Meganimus - Open portal: {portal_name}",
        "LANGUAGE": "Language:",
        "LANGUAGE_SET_ERROR": "[Error] Failed to set LC_ALL: {error}",
        "MANDATORY_FIELDS_ERROR": "Name and game are required.",
        "MODIFY_PORTAL": "Modify portal",
        "MULTIPLE_PORTAL_CREATOR": "Creator of multiple portals",
        "MULTIPLE_PORTAL_REMOVER": "Multiple portal remover",
        "NAME_INVALID": "The name is invalid, select another.",
        "NAME_INVALID_IN_MULTIPLE": "The name '{name}' is invalid, select another.",
        "NO_BUTTON": "No",
        "NO_COMMAND_DEFINED": "No command/path defined",
        "NO_HERO_IMAGES": "No hero images found.",
        "NO_PORTAL_SELECTED_ERROR": "No portal selected.",
        "NO_PORTAL_SELECTED_MULTIPLE": "No portal selected",
        "NO_PORTALS_FOUND": "No portals were found.",
        "NO_PYQT6_FOUND_ERROR": "PyQt6 not found.",
        "NO_RESULTS": "No results.",
        "OK_BUTTON": "OK",
        "OPEN_GAME_PATH": "Open game folder",
        "OPEN_PATH_ERROR": "Could not find this path on your device:<br>{path}",
        "PLACEHOLDER_FOR_LANGUAGE": "- No language chosen -",
        "QT_STYLE": "QT style:",
        "REMOVE": "Remove",
        "REMOVE_MULTIPLE_PORTALS": "Remove multiple PORTALs",
        "REMOVE_SELECTED": "Remove selected",
        "EXECUTOR": "Executor:",
        "RUNNING_COMMAND": "Running command: {command}",
        "SAVE_BUTTON": "Save",
        "SEARCH": "Search",
        "SELECT": "Select",
        "SELECT_AT_LEAST_ONE_IMAGE": "Select at least one image.",
        "SELECT_FILE": "Select file",
        "SELECT_GAME": "Select game",
        "SELECT GAME FOLDER": "Select game folder",
        "SELECT_PORTAL_ART": "Select art",
        "SELECT_VERSION": "- Select a version -",
        "SETTINGS_SAVED_RESTART": "Changes saved.<br>Restart Meganimus to apply visual changes.",
        "SGDB_API_KEY_LABEL": "SteamGridDB API Key:",
        "SHOW_FPS_OPTION": "Show FPS with:",
        "START": "Start",
        "START_PORTAL": "Start portal",
        "STARTING_PORTAL": "Starting portal: {name}",
        "STOP_ACCESS_ERROR": "[Stop] Error accessing process: {error}",
        "STOP_CURRENT": "Stop current",
        "STOP_PORTAL": "Stop portal",
        "STOP_PORTAL_SUCCESS": "[Stop] portal terminated successfully.",
        "STOP_KILL_ERROR": "[Stop] Error killing process {pid}: {error}",
        "STOP_KILL_PROCESS": "[Stop] Killing process {pid} ({exe})",
        "STOP_NO_PORTAL_ACTIVE": "[Stop] No portal active.",
        "STOP_NO_PROCESS_FOUND": "[Stop] No portal process found to terminate.",
        "STOP_PROCESS_SUCCESS": "[Stop] Process {pid} terminated successfully.",
        "TEMP_FILES_REMOVED": "Temporary files removed: {count}",
        "TRANSFER": "Transfer",
        "TRANSFER_ERROR": "Transfer error",
        "TRANSFER_FAILED": "Transfer failed: {error}",
        "TRANSFER_HEROES": "Heroes",
        "TRANSFER_HEROES_TITLE": "Heroes image transfer",
        "TRANSFER_SUMMARY": "Transferred to:\n{dir}",
        "USING_PYQT6": "Using PyQt6",
        "YES_BUTTON": "Yes",
        "MEGANIMUS_CLOSED": "Meganimus closed. Finalizing processes...",
        "MEGANIMUS_SETTINGS": "Meganimus preferences",
    },
    'pt_BR': {
        "ABOUT_TEXT_HTML": f"""<b>Meganimus</b><br>
        Versão: {__version__}<br><br>
        Um launcher para centralizar seus jogos nativos de Linux e de emuladores.<br>
        Licença: <a href='https://www.gnu.org/licenses/gpl-3.0.html'>GPLv3</a><br>
        Criado por {__creator__}""",
        "ABOUT_MEGANIMUS": "Sobre o Meganimus",
        "ADD_FILES": "Adicionar arquivos",
        "ADD_FOLDER": "Adicionar pasta",
        "API_FAIL": "Erro de API:\n{e}",
        "API_KEY_REQUIRED_SGDB": "Por favor, insira sua chave da API do SteamGridDB.",
        "API_KEY_SAVED": "Chave de API salva",
        "API_KEY_SAVE_ERROR": "Não foi possível salvar a chave:\n{e}",
        "API_KEY_SAVE_FIRST": "Salve sua API KEY primeiro.",
        "APP_NAME": "Meganimus",
        "BROWSE_BUTTON": "Procurar",
        "CANCEL_BUTTON": "Cancelar",
        "CLEAR_LIST": "Limpar lista",
        "CONFIRM_CLOSE_MESSAGE": "Deseja encerrar o portal atual e fechar o Meganimus?",
        "CONFIRM_REMOVE": "Remover '{name}'?",
        "CREATE_PORTAL": "Criar portal",
        "DEBUG_REAL_PORTAL_INITIATED": "[DEBUG] Portal iniciada como PID {pid}",
        "DEBUG_TEMP_FILE_REMOVED": "[DEBUG] Arquivo temporário removido: {path}",
        "DELETE_PORTAL_CONFIRM_MESSAGE": "Tem certeza de que deseja remover o portal '{name}'?",
        "DELETE_PORTALS_CONFIRM_MESSAGE": "Tem certeza de que deseja remover os portais selecionados?",
        "DONE": "Concluído",
        "DUPLICATE_NAME_IN_LIST": "Já existe outro portal na lista com o nome: {name}",
        "ENTER_GAME_NAME": "Digite o nome de um jogo.",
        "ENVIRONMENT_VARS": "Variáveis:",
        "ERROR": "Erro",
        "ERROR_LOADING_FILE": "Erro ao carregar arquivo {file}: {error}",
        "ERROR_REMOVING_FILE": "Erro ao remover {file}: {error}",
        "ERROR_TRANSFERRING_URL": "Erro ao transferir {url}: {error}",
        "EXECUTOR_COMMAND": "Comando:",
        "EXECUTOR_VERSION": "Versão:",
        "EXECUTORS": "Executores:",
        "EXTRAS": "Extras",
        "EXTRACTING": "Extraindo: {name}",
        "GAME_FILE_FILTER": "Todos os arquivos (*)",
        "GAME_PATH": "Jogo:",
        "FAILED_UPDATE_JSON": "Não foi possível atualizar as informações do portal: {error}",
        "FILE": "Arquivo",
        "FOLDER": "Pasta",
        "FPS_GALLIUM_HUD": "Gallium HUD (Nem sempre compatível)",
        "GAMEMODE": "Usar Feral gamemode",
        "HEROES_LOAD_ERROR": "[DEBUG] Falha ao carregar heroes: {error}",
        "HIDE_PORTAL_IMAGES": "Ocultar imagens da lista",
        "IMAGE_FILTER": "Arquivos de imagem (*.jpg *.jpeg *.png *.webp);;Todos os arquivos (*)",
        "PORTAL": "Portal",
        "PORTAL_ALREADY_ACTIVE": "Encerrar portal atual e iniciar o selecionado?",
        "PORTAL_ALREADY_EXISTS": "Já existe um portal com esse nome. Escolha outro.",
        "PORTAL_ARGS": "Argumentos:",
        "PORTAL_ART_PATH": "Arte:",
        "PORTAL_INFO_ERROR": "Não foi possível acessar/executar o jogo ou encontrar informações sobre esse portal.",
        "PORTAL_INFO_LOADED": "Informações do portal carregadas com sucesso: {name}",
        "PORTAL_LANGUAGE": "Idioma (Localidade):",
        "PORTAL_NAME": "Nome:",
        "PORTAL_IN_MULTIPLE_CREATE_ALREADY_EXISTS": "O Portal '{name}' já existe, use outro nome.",
        "PORTAL_START_ERROR": "Ocorreu um erro ao tentar iniciar o portal: {error}",
        "PORTAL_STARTED": "Meganimus - Portal aberto: {portal_name}",
        "LANGUAGE": "Idioma:",
        "LANGUAGE_SET_ERROR": "[Erro] Falha ao definir LC_ALL: {error}",
        "MANDATORY_FIELDS_ERROR": "Nome e jogo são obrigatórios.",
        "MODIFY_PORTAL": "Modificar portal",
        "MULTIPLE_PORTAL_CREATOR": "Criador de múltiplos portais",
        "MULTIPLE_PORTAL_REMOVER": "Removedor de múltiplos portais",
        "NAME_INVALID": "O nome é inválido, selecione outro.",
        "NAME_INVALID_IN_MULTIPLE": "O nome '{name}' é inválido, selecione outro.",
        "NO_BUTTON": "Não",
        "NO_COMMAND_DEFINED": "Nenhum comando/caminho definido",
        "NO_HERO_IMAGES": "Nenhuma imagem hero encontrada.",
        "NO_PORTAL_SELECTED_ERROR": "Nenhum portal selecionado.",
        "NO_PORTAL_SELECTED_MULTIPLE": "Nenhum portal selecionado",
        "NO_PORTALS_FOUND": "Nenhum portal foi encontrado.",
        "NO_PYQT6_FOUND_ERROR": "PyQt6 não encontrado.",
        "NO_RESULTS": "Nenhum resultado.",
        "OK_BUTTON": "OK",
        "OPEN_GAME_PATH": "Abrir pasta do jogo",
        "OPEN_PATH_ERROR": "Não foi possível encontrar esse caminho no seu dispositivo:<br>{path}",
        "PLACEHOLDER_FOR_LANGUAGE": "- Sem idioma escolhido -",
        "PREFIX_PATH": "Prefixo:",
        "QT_STYLE": "Estilo do QT:",
        "REMOVE": "Remover",
        "REMOVE_MULTIPLE_PORTALS": "Remover vários portais",
        "REMOVE_SELECTED": "Remover selecionado",
        "EXECUTOR": "Executor:",
        "RUNNING_COMMAND": "Executando comando: {command}",
        "SAVE_BUTTON": "Salvar",
        "SEARCH": "Pesquisar",
        "SELECT": "Selecionar",
        "SELECT_AT_LEAST_ONE_IMAGE": "Selecione pelo menos uma imagem.",
        "SELECT_FILE": "Selecionar arquivo",
        "SELECT_GAME": "Selecionar jogo",
        "SELECT_GAME_FOLDER": "Selecionar pasta do jogo",
        "SELECT_PORTAL_ART": "Selecionar arte",
        "SELECT_VERSION": "- Selecione uma versão -",
        "SETTINGS_SAVED_RESTART": "Alterações salvas.<br>Reinicie o Meganimus para aplicar as mudanças visuais.",
        "SGDB_API_KEY_LABEL": "Chave da API SteamGridDB:",
        "SHOW_FPS_OPTION": "Mostrar FPS com:",
        "START": "Iniciar",
        "START_PORTAL": "Iniciar portal",
        "STARTING_PORTAL": "Iniciando portal: {name}",
        "STOP_ACCESS_ERROR": "[Parar] Erro ao acessar processo: {error}",
        "STOP_CURRENT": "Encerrar atual",
        "STOP_PORTAL": "Encerrar portal",
        "STOP_PORTAL_SUCCESS": "[Parar] Portal encerrado com sucesso.",
        "STOP_KILL_ERROR": "[Parar] Erro ao encerrar processo {pid}: {error}",
        "STOP_KILL_PROCESS": "[Parar] Encerrando processo {pid} ({exe})",
        "STOP_NO_PORTAL_ACTIVE": "[Parar] Nenhum portal ativo.",
        "STOP_NO_PROCESS_FOUND": "[Parar] Nenhum processo de portal encontrado para encerrar.",
        "STOP_PROCESS_SUCCESS": "[Parar] Processo {pid} encerrado com sucesso.",
        "TEMP_FILES_REMOVED": "Arquivos temporários removidos: {count}",
        "TRANSFER": "Transferir",
        "TRANSFER_ERROR": "Erro na transferência",
        "TRANSFER_FAILED": "Falha na transferência: {error}",
        "TRANSFER_HEROES": "Heroes",
        "TRANSFER_HEROES_TITLE": "Transferidor de imagens heroes",
        "TRANSFER_SUMMARY": "Transferido para:\n{dir}",
        "USING_PYQT6": "Usando PyQt6",
        "YES_BUTTON": "Sim",
        "MEGANIMUS_CLOSED": "Meganimus fechado. Finalizando processos...",
        "MEGANIMUS_SETTINGS": "Preferências do Meganimus",
    }
}

def tr(key, **kwargs):
    translation_dict = TRANSLATIONS.get(LANG, TRANSLATIONS['en_US'])
    translated_string = translation_dict.get(key, TRANSLATIONS['en_US'].get(key, key))
    
    try:
        return translated_string.format(**kwargs)
    except KeyError:
        return translated_string

# PyQt6 Imports
try:
    from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QListWidget, QPushButton, QMessageBox, QToolBar, QDialog, QGridLayout, QLabel, QLineEdit, QHBoxLayout, QFileDialog, QComboBox, QTextEdit, QCheckBox, QTabWidget, QProgressDialog, QListWidgetItem, QSizePolicy, QApplication, QStyleFactory, QProgressBar, QButtonGroup, QSplitter, QScrollArea, QRadioButton, QAbstractItemView, QFormLayout, QLayout, QWidgetAction, QTreeWidget, QTreeWidgetItem)
    from PyQt6.QtCore import Qt, QThread, pyqtSignal, QSize, QMetaEnum, QTimer, QEvent, QSettings
    from PyQt6.QtGui import QAction, QIcon, QPixmap, QFont
    print(tr('USING_PYQT6'))
except ImportError:
    print(tr('NO_PYQT6_FOUND_ERROR'))
    sys.exit(1)

# Meganimus settings (JSON)
# $HOME/Meganimus/config/meganimus-settings.json
CONFIG_DIR = Path.home() / "AppsFiles" / "Meganimus" / "config"
SETTINGS_PATH = CONFIG_DIR / "meganimus-settings.json"

def detect_default_settings() -> dict:
    """Detects Qt style and provides default language only for first-time creation."""
    available = QStyleFactory.keys()
    if "Oxygen" in available:
        style = "Oxygen"
    elif "kvantum" in available:
        style = "kvantum"
    elif "Breeze" in available:
        style = "Breeze"
    elif "Windows" in available:
        style = "Windows"
    else:
        style = None

    return {
        "qt_style": style,
        "language": LANG if LANG else "en_US",  # Only for first creation
        "hide_portal_images": False,
        "azaharplus_executor": "OFF",
        "azaharplus_command": "",
        "cemu_executor": "OFF",
        "cemu_command": "",
        "dolphin_executor": "OFF",
        "dolphin_command": "",
        "duckstation_executor": "OFF",
        "duckstation_command": "",
        "melonds_executor": "OFF",
        "melonds_command": "",
        "mgba_executor": "OFF",
        "mgba_command": "",
        "pcsx2_executor": "OFF",
        "pcsx2_command": "",
        "ppsspp_executor": "OFF",
        "ppsspp_command": "",
        "rpcs3_executor": "OFF",
        "rpcs3_command": "",
        "ryubing_executor": "OFF",
        "ryubing_command": ""
    }

def load_settings() -> dict:
    """Loads settings, recreates only qt_style if invalid."""
    defaults = detect_default_settings()

    try:
        with open(SETTINGS_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)
    except Exception:
        # First creation: save qt_style + language
        save_settings(defaults)
        return defaults

    # Check consistency of qt_style only
    if data.get("qt_style") not in QStyleFactory.keys():
        data["qt_style"] = defaults["qt_style"]
        save_settings(data)

    return data

def save_settings(data: dict) -> None:
    """Saves settings in JSON."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    with open(SETTINGS_PATH, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

class AddPortalDialog(QDialog):
    portal_saved = pyqtSignal()

    def __init__(self, parent=None, portal_data=None):
        super().__init__(parent)
        self.portal_data = portal_data

        if self.portal_data:
            self.setWindowTitle(tr('MODIFY_PORTAL'))
        else:
            self.setWindowTitle(tr('CREATE_PORTAL'))

        self.resize(600, 400)
        self.main_layout = QGridLayout(self)

        # Portal name
        self.name_label = QLabel(tr('PORTAL_NAME'))
        self.name_input = QLineEdit()
        self.main_layout.addWidget(self.name_label, 0, 0)
        self.main_layout.addWidget(self.name_input, 0, 1, 1, 2)

        # Executor option
        self.executor_label = QLabel(tr("EXECUTOR"))
        self.executor_combo = QComboBox()

        # Always adds "Linux" as default
        self.executor_combo.addItem("Linux", userData="Linux")

        # Loads saved settings
        settings = load_settings()

        # List of configurable emulators
        emulators = ["AzaharPlus", "Cemu", "Dolphin", "Duckstation", "MelonDS", "mGBA", "PCSX2", "PPSSPP", "RPCS3", "Ryubing"]

        for emulator in emulators:
            executor = settings.get(f"{emulator.lower()}_executor", "OFF")
            command = settings.get(f"{emulator.lower()}_command", "")
            
            if executor != "OFF" and command:
                # Displays the name of the saved executor in the combobox
                self.executor_combo.addItem(f"{emulator} ({executor})", userData=emulator)

        # Add to layout (line 1, after PORTAL_NAME)
        self.main_layout.addWidget(self.executor_label, 1, 0)
        self.main_layout.addWidget(self.executor_combo, 1, 1, 1, 2)
        self.executor_combo.currentIndexChanged.connect(self.update_options_state)

        # "Game / Folder" line
        self.game_path_label = QLabel(tr('GAME_PATH'))
        self.game_path_input = QLineEdit()

        # Default button to select file
        self.game_file_button = QPushButton(tr('FILE'))
        self.game_file_button.clicked.connect(self.select_file)

        # Alternative button to select folder
        self.game_folder_button = QPushButton(tr('FOLDER'))
        self.game_folder_button.clicked.connect(self.select_folder)

        # Horizontal layout with two buttons
        game_buttons_widget = QWidget()
        game_buttons_layout = QHBoxLayout(game_buttons_widget)
        game_buttons_layout.setContentsMargins(0, 0, 0, 0)
        game_buttons_layout.setSpacing(6)
        game_buttons_layout.addWidget(self.game_file_button)
        game_buttons_layout.addWidget(self.game_folder_button)

        # Add everything to the grid
        self.main_layout.addWidget(self.game_path_label, 2, 0)
        self.main_layout.addWidget(self.game_path_input, 2, 1)
        self.main_layout.addWidget(game_buttons_widget, 2, 2)

        # Portal art
        self.portal_art_label = QLabel(tr('PORTAL_ART_PATH'))
        self.portal_art_input = QLineEdit()
        self.portal_art_button = QPushButton(tr('BROWSE_BUTTON'))
        self.portal_art_button.clicked.connect(self.select_portal_art)
        self.main_layout.addWidget(self.portal_art_label, 3, 0)
        self.main_layout.addWidget(self.portal_art_input, 3, 1)
        self.main_layout.addWidget(self.portal_art_button, 3, 2)

        # Language/location
        self.language_label = QLabel(tr('PORTAL_LANGUAGE'))
        self.language_input = QComboBox()
        self.language_input.addItems([
            tr('PLACEHOLDER_FOR_LANGUAGE'),
            'English (en_US.UTF-8)',
            'Português Brasil (pt_BR.UTF-8)',
            'Português Portugal (pt_PT.UTF-8)',
            'Español España (es_ES.UTF-8)',
            'Español México (es_MX.UTF-8)',
            'Français (fr_FR.UTF-8)',
            'Deutsch (de_DE.UTF-8)',
            'Italiano (it_IT.UTF-8)',
            'Русский (ru_RU.UTF-8)',
            'Українська (uk_UA.UTF-8)',
            'Polski (pl_PL.UTF-8)',
            'Česky (cs_CZ.UTF-8)',
            'Slovenčina (sk_SK.UTF-8)',
            'Magyar (hu_HU.UTF-8)',
            'Română (ro_RO.UTF-8)',
            'Nederlands (nl_NL.UTF-8)',
            'Svenska (sv_SE.UTF-8)',
            'Norsk Bokmål (nb_NO.UTF-8)',
            'Dansk (da_DK.UTF-8)',
            'Suomi (fi_FI.UTF-8)',
            'Ελληνικά (el_GR.UTF-8)',
            'Български (bg_BG.UTF-8)',
            '日本語 (ja_JP.UTF-8)',
            '한국어 (ko_KR.UTF-8)',
            '简体中文 (zh_CN.UTF-8)',
            '繁體中文 (zh_TW.UTF-8)',
            'العربية (ar_SA.UTF-8)',
            'فارسی (fa_IR.UTF-8)',
            'Türkçe (tr_TR.UTF-8)',
            'हिन्दी (hi_IN.UTF-8)',
            'ไทย (th_TH.UTF-8)',
            'עברית (he_IL.UTF-8)',
        ])
        self.main_layout.addWidget(self.language_label, 4, 0)
        self.main_layout.addWidget(self.language_input, 4, 1, 1, 2)

        # Gamemode
        self.gamemode_checkbox = QCheckBox(tr('GAMEMODE'))
        self.gamemode_checkbox.setChecked(True)
        self.main_layout.addWidget(self.gamemode_checkbox, 5, 0, 1, 3)

        # FPS HUD
        self.fps_layout = QHBoxLayout()
        self.show_fps_checkbox = QCheckBox(tr('SHOW_FPS_OPTION'))
        self.show_fps_checkbox.setChecked(False)
        self.fps_hud_combo = QComboBox()
        self.fps_hud_options = [
            ("FPS_GALLIUM_HUD", tr("FPS_GALLIUM_HUD")),
            #("FPS_MANGOHUD", tr("FPS_MANGOHUD"))
        ]
        for id, text in self.fps_hud_options:
            self.fps_hud_combo.addItem(text, id)
        self.show_fps_checkbox.stateChanged.connect(self.update_fps_hud_state)
        self.fps_layout.addWidget(self.show_fps_checkbox)
        self.fps_layout.addWidget(self.fps_hud_combo)
        self.fps_hud_combo.setEnabled(False)
        self.main_layout.addLayout(self.fps_layout, 6, 0, 1, 3)

        self.update_options_state()

        # Environment variables
        self.env_vars_label = QLabel(tr("ENVIRONMENT_VARS"))
        self.env_vars_input = QLineEdit()
        self.main_layout.addWidget(self.env_vars_label, 7, 0)
        self.main_layout.addWidget(self.env_vars_input, 7, 1, 1, 2)

        # Arguments
        self.portal_args_label = QLabel(tr('PORTAL_ARGS'))
        self.portal_args_input = QLineEdit()
        self.main_layout.addWidget(self.portal_args_label, 8, 0)
        self.main_layout.addWidget(self.portal_args_input, 8, 1, 1, 2)

        # Avoid entering by pressing buttons
        self.name_input.installEventFilter(self)
        self.game_path_input.installEventFilter(self)
        self.portal_art_input.installEventFilter(self)
        self.env_vars_input.installEventFilter(self)
        self.portal_args_input.installEventFilter(self)

        # Buttons
        self.buttons_layout = QHBoxLayout()
        self.remove_portal_button = QPushButton(tr('REMOVE'))
        self.save_button = QPushButton(tr('SAVE_BUTTON'))
        self.save_button.clicked.connect(self.save_and_accept)

        if self.portal_data:
            self.buttons_layout.addWidget(self.remove_portal_button)
            self.remove_portal_button.clicked.connect(self.delete_portal)

        self.buttons_layout.addStretch()
        self.buttons_layout.addWidget(self.save_button)
        self.main_layout.addLayout(self.buttons_layout, 10, 0, 1, 3)

        if self.portal_data:
            self.load_portal_data()

    def eventFilter(self, obj, event):
        if event.type() == QEvent.Type.KeyPress:
            if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
                return True
        return super().eventFilter(obj, event)

    def update_fps_hud_state(self, state):
        self.fps_hud_combo.setEnabled(self.show_fps_checkbox.isChecked())

    def load_portal_data(self):
        self.name_input.setText(self.portal_data.get('name', ''))
        self.game_path_input.setText(self.portal_data.get('game_path', ''))
        self.portal_art_input.setText(self.portal_data.get('art_path', ''))

        # Executor salvo
        saved_executor = self.portal_data.get('executor', 'Linux')
        index_executor = self.executor_combo.findData(saved_executor)
        if index_executor != -1:
            self.executor_combo.setCurrentIndex(index_executor)

        env_vars_text = self.portal_data.get('env_vars', '').strip()
        self.env_vars_input.setText(env_vars_text)

        self.portal_args_input.setText(self.portal_data.get('portal_args', ''))

        language = self.portal_data.get('language', '')
        index_lang = self.language_input.findText(language)
        if index_lang != -1:
            self.language_input.setCurrentIndex(index_lang)

        use_gamemode = self.portal_data.get('use_gamemode', True)
        self.gamemode_checkbox.setChecked(use_gamemode)

        show_fps = self.portal_data.get('show_fps', False)
        self.show_fps_checkbox.setChecked(show_fps)
        self.update_fps_hud_state(Qt.CheckState.Checked if show_fps else Qt.CheckState.Unchecked)

        fps_hud_type = self.portal_data.get('fps_hud_type', '')
        index_hud = self.fps_hud_combo.findData(fps_hud_type)
        if index_hud != -1:
            self.fps_hud_combo.setCurrentIndex(index_hud)

    def update_options_state(self):
        executor = self.executor_combo.currentData()
        
        # Language
        self.language_input.setEnabled(executor == "Linux")
        
        # FPS HUD, only enabled if executor is Linux
        if executor == "Linux":
            self.show_fps_checkbox.setEnabled(True)
        else:
            self.show_fps_checkbox.setEnabled(False)
            self.show_fps_checkbox.setChecked(False)
        
        # Updates the state of the combobox
        self.update_fps_hud_state(self.show_fps_checkbox.checkState())

    def select_file(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr("SELECT_GAME"),
            "",
            "",
        )
        if file_path:
            self.game_path_input.setText(file_path)

    def select_folder(self):
        folder_path = QFileDialog.getExistingDirectory(
            self,
            tr("SELECT_GAME_FOLDER"),
            "",
        )
        if folder_path:
            self.game_path_input.setText(folder_path)

    def select_portal_art(self):
        art_dir = Path(self.parent().meganimus_dir) / "heroes"
        art_dir.mkdir(parents=True, exist_ok=True)
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            tr('SELECT_PORTAL_ART'),
            str(art_dir),
            tr('IMAGE_FILTER')
        )
        if file_path:
            self.portal_art_input.setText(file_path)

    def get_form_data(self):
        env_vars_text = self.env_vars_input.text().strip()
        selected_lang = self.language_input.currentText()
        if selected_lang == tr('PLACEHOLDER_FOR_LANGUAGE'):
            selected_lang = ""

        fps_hud_type = self.fps_hud_combo.currentData()

        art_path = self.portal_art_input.text().strip()
        if not art_path:
            art_path = self.resolve_default_art_path(self.name_input.text())

        return {
            "name": self.name_input.text(),
            "executor": self.executor_combo.currentData(),
            "game_path": self.game_path_input.text(),
            "art_path": art_path,
            "language": selected_lang,
            "use_gamemode": self.gamemode_checkbox.isChecked(),
            "env_vars": env_vars_text,
            "portal_args": self.portal_args_input.text(),
            "show_fps": self.show_fps_checkbox.isChecked(),
            "fps_hud_type": fps_hud_type,
        }

    def resolve_default_art_path(self, portal_name: str) -> str:
        heroes_dir = Path.home() / "AppsFiles" / "Meganimus" / "heroes"
        for folder in heroes_dir.iterdir():
            if folder.is_dir() and folder.name.lower() == portal_name.lower():
                for ext in ("*.jpg", "*.jpeg", "*.png", "*webp"):
                    images = list(folder.glob(ext))
                    if images:
                        return str(images[0])
        return ""

    def save_and_accept(self):
        portal_data = self.get_form_data()
        if portal_data["name"] and portal_data["game_path"]:
            config_dir = Path.home() / "AppsFiles" / "Meganimus" / "config"
            art_dir = Path.home() / "AppsFiles" / "Meganimus" / "art"
            config_dir.mkdir(parents=True, exist_ok=True)
            art_dir.mkdir(parents=True, exist_ok=True)

            safe_name = portal_data["name"].replace(" ", "_").lower()
            portal_file = config_dir / f"portal-info-{safe_name}.json"

            # Check for duplicate portal name
            if portal_file.exists() and (not self.portal_data or self.portal_data.get("name", "").lower() != portal_data["name"].lower()):
                QMessageBox.warning(self, tr("ERROR"), tr("PORTAL_ALREADY_EXISTS"))
                return

            # Handle artwork copy or rename
            if portal_data.get("art_path") and (not self.portal_data or portal_data["art_path"] != self.portal_data.get("art_path")):
                # User selected a new image
                # Remove old images with old name
                if self.portal_data:
                    old_safe_name = self.portal_data.get('name', '').replace(" ", "_").lower()
                    for old_file in art_dir.glob(f"{old_safe_name}.*"):
                        try:
                            old_file.unlink()
                        except Exception:
                            pass

                # Copy new image
                art_path = Path(portal_data["art_path"])
                art_extension = art_path.suffix.lower()
                art_filename = f"{safe_name}{art_extension}"
                art_destination = art_dir / art_filename
                try:
                    shutil.copyfile(art_path, art_destination)
                    portal_data["art_path"] = str(art_destination)
                except Exception:
                    portal_data["art_path"] = ""
            elif self.portal_data and self.portal_data.get("art_path"):
                # No new image selected, rename old art if portal name changed
                old_art_path = Path(self.portal_data['art_path'])
                if old_art_path.exists():
                    old_safe_name = self.portal_data.get('name', '').replace(" ", "_").lower()
                    if old_safe_name != safe_name:
                        # Remove any old images with old name
                        for old_file in art_dir.glob(f"{old_safe_name}.*"):
                            try:
                                old_file.unlink()
                            except Exception:
                                pass

                        new_art_path = art_dir / f"{safe_name}{old_art_path.suffix.lower()}"
                        try:
                            old_art_path.rename(new_art_path)
                            portal_data["art_path"] = str(new_art_path)
                        except Exception:
                            portal_data["art_path"] = str(old_art_path)

            # Save JSON
            try:
                with open(portal_file, 'w', encoding="utf-8") as f:
                    json.dump(portal_data, f, indent=4, ensure_ascii=False)
            except Exception as e:
                QMessageBox.critical(self, tr('ERROR'), tr('NAME_INVALID', error=str(e)))
                return

            # Remove old JSON if name changed
            if self.portal_data:
                old_safe_name = self.portal_data.get('name', '').replace(" ", "_").lower()
                new_safe_name = portal_data['name'].replace(" ", "_").lower()
                if old_safe_name != new_safe_name:
                    old_portal_file_path = config_dir / f"portal-info-{old_safe_name}.json"
                    if old_portal_file_path.exists():
                        old_portal_file_path.unlink()

            self.portal_saved.emit()
            self.accept()
        else:
            QMessageBox.warning(self, tr('CREATE_PORTAL'), tr('MANDATORY_FIELDS_ERROR'))

    def delete_portal(self):
        portal_name = self.name_input.text().strip()
        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle(tr('REMOVE'))
        msg.setText(tr('DELETE_PORTAL_CONFIRM_MESSAGE', name=portal_name))
        msg.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg.button(QMessageBox.StandardButton.Yes).setText(tr('YES_BUTTON'))
        msg.button(QMessageBox.StandardButton.No).setText(tr('NO_BUTTON'))

        if msg.exec() != QMessageBox.StandardButton.Yes:
            return

        config_dir = Path.home() / "AppsFiles" / "Meganimus" / "config"
        safe_name = portal_name.replace(" ", "_").lower()
        portal_file = config_dir / f"portal-info-{safe_name}.json"

        if not portal_file.exists():
            QMessageBox.critical(self, tr('ERROR'), tr('PORTAL_INFO_ERROR'))
            return

        # Load portal data before removing
        with open(portal_file, encoding='utf-8') as f:
            portal_data = json.load(f)

        # Remove the configuration file
        portal_file.unlink()

        # Removes the associated artwork, if it exists.
        art = portal_data.get('art_path')
        if art:
            art_path = Path(art)
            if art_path.exists() and art_path.is_file():
                try:
                    art_path.unlink()
                except Exception as e:
                    print(tr("WARNING_DELETE_PORTAL_ART", e=e))

        self.parent().load_portals()
        self.accept()

class MultipleCreatePortalsDialog(QDialog):
    portals_saved = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("MULTIPLE_PORTAL_CREATOR"))
        self.resize(600, 400)

        layout = QVBoxLayout(self)
        self.main_layout = layout  # Required to add child layouts

        # Executor and combobox side by side
        executor_layout = QHBoxLayout()
        executor_label = QLabel(tr("EXECUTOR"))
        self.executor_combo = QComboBox()
        self.executor_combo.addItem("Linux", userData="Linux")

        settings = load_settings()
        emulators = ["AzaharPlus", "Cemu", "Dolphin", "Duckstation", "MelonDS", "mGBA", "PCSX2", "PPSSPP", "RPCS3", "Ryubing"]
        for emulator in emulators:
            executor = settings.get(f"{emulator.lower()}_executor", "OFF")
            command = settings.get(f"{emulator.lower()}_command", "")
            if executor != "OFF" and command:
                self.executor_combo.addItem(f"{emulator} ({executor})", userData=emulator)

        executor_layout.addWidget(executor_label)
        executor_layout.addWidget(self.executor_combo)
        self.main_layout.addLayout(executor_layout)
        self.executor_combo.currentIndexChanged.connect(self.update_language_state)

        # Language and combobox side by side
        language_layout = QHBoxLayout()
        language_label = QLabel(tr("PORTAL_LANGUAGE"))
        self.language_input = QComboBox()
        self.language_input.addItems([
            tr('PLACEHOLDER_FOR_LANGUAGE'),
            'English (en_US.UTF-8)',
            'Português Brasil (pt_BR.UTF-8)',
            'Português Portugal (pt_PT.UTF-8)',
            'Español España (es_ES.UTF-8)',
            'Español México (es_MX.UTF-8)',
            'Français (fr_FR.UTF-8)',
            'Deutsch (de_DE.UTF-8)',
            'Italiano (it_IT.UTF-8)',
            'Русский (ru_RU.UTF-8)',
            'Українська (uk_UA.UTF-8)',
            'Polski (pl_PL.UTF-8)',
            'Česky (cs_CZ.UTF-8)',
            'Slovenčina (sk_SK.UTF-8)',
            'Magyar (hu_HU.UTF-8)',
            'Română (ro_RO.UTF-8)',
            'Nederlands (nl_NL.UTF-8)',
            'Svenska (sv_SE.UTF-8)',
            'Norsk Bokmål (nb_NO.UTF-8)',
            'Dansk (da_DK.UTF-8)',
            'Suomi (fi_FI.UTF-8)',
            'Ελληνικά (el_GR.UTF-8)',
            'Български (bg_BG.UTF-8)',
            '日本語 (ja_JP.UTF-8)',
            '한국어 (ko_KR.UTF-8)',
            '简体中文 (zh_CN.UTF-8)',
            '繁體中文 (zh_TW.UTF-8)',
            'العربية (ar_SA.UTF-8)',
            'فارسی (fa_IR.UTF-8)',
            'Türkçe (tr_TR.UTF-8)',
            'हिन्दी (hi_IN.UTF-8)',
            'ไทย (th_TH.UTF-8)',
            'עברית (he_IL.UTF-8)',
        ])
        language_layout.addWidget(language_label)
        language_layout.addWidget(self.language_input)
        self.main_layout.addLayout(language_layout)

        # List of files/folders with editable name
        self.file_list = QTreeWidget()
        self.file_list.setColumnCount(1)
        self.file_list.setHeaderHidden(True)
        self.file_list.setExpandsOnDoubleClick(True)
        self.file_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        layout.addWidget(self.file_list)

        # Buttons to add/remove files/folders
        btn_layout = QHBoxLayout()
        self.add_files_button = QPushButton(tr("ADD_FILES"))
        self.add_files_button.clicked.connect(self.add_files)

        self.add_folders_button = QPushButton(tr("ADD_FOLDER"))
        self.add_folders_button.clicked.connect(self.add_folders)

        self.remove_button = QPushButton(tr("REMOVE_SELECTED"))
        self.remove_button.clicked.connect(self.remove_selected_item)

        btn_layout.addWidget(self.add_files_button)
        btn_layout.addWidget(self.add_folders_button)
        btn_layout.addWidget(self.remove_button)
        layout.addLayout(btn_layout)

        # Save button
        action_layout = QHBoxLayout()
        self.save_button = QPushButton(tr("SAVE_BUTTON"))
        self.save_button.clicked.connect(self.save_multiple)
        action_layout.addStretch()
        action_layout.addWidget(self.save_button)
        layout.addLayout(action_layout)

        self.paths = []

    def remove_selected_item(self):
        selected = self.file_list.currentItem()
        if selected and hasattr(selected, "path"):
            index = self.file_list.indexOfTopLevelItem(selected)
            self.file_list.takeTopLevelItem(index)
            self.paths.remove(selected.path)

    def update_language_state(self):
        executor = self.executor_combo.currentData()
        self.language_input.setEnabled(executor == "Linux")

    def add_files(self):
        files, _ = QFileDialog.getOpenFileNames(self, tr("SELECT_GAME"), "", "")
        for f in files:
            self.add_file_item(f)

    def add_folders(self):
        folder = QFileDialog.getExistingDirectory(self, tr("SELECT_GAME_FOLDER"), "")
        if folder:
            self.add_file_item(folder)

    def guess_portal_art(self, portal_name):
        heroes_dir = Path.home() / "AppsFiles" / "Meganimus" / "heroes"
        if not heroes_dir.exists():
            return ""
        for folder in heroes_dir.iterdir():
            if folder.is_dir() and folder.name.lower() == portal_name.lower():
                for ext in ("*.jpg", "*.jpeg", "*.png", "*.webp"):
                    images = list(folder.glob(ext))
                    if images:
                        return str(images[0])
        return ""

    def setup_file_list(self):
        # Configure QTreeWidget columns
        self.file_list = QTreeWidget()
        self.file_list.setColumnCount(1)  # One widget per line (container)
        self.file_list.setHeaderHidden(True)  # Hide header
        self.file_list.setSelectionMode(QTreeWidget.SingleSelection)
        self.layout().addWidget(self.file_list)

    def add_file_item(self, path):
        if path in self.paths:
            return
        self.paths.append(path)

        # Main container for the item
        item_widget = QWidget()
        main_layout = QVBoxLayout(item_widget)
        main_layout.setContentsMargins(2, 2, 2, 2)
        main_layout.setSpacing(4)

        # Portal name line
        name_layout = QHBoxLayout()
        name_label = QLabel(tr("PORTAL_NAME"))
        name_input = QLineEdit(Path(path).stem)
        name_layout.addWidget(name_label)
        name_layout.addWidget(name_input)
        main_layout.addLayout(name_layout)

        # Gamemode line
        gamemode_layout = QHBoxLayout()
        gamemode_checkbox = QCheckBox(tr("GAMEMODE"))
        gamemode_checkbox.setChecked(True)
        gamemode_layout.addWidget(gamemode_checkbox)
        gamemode_layout.addStretch()
        main_layout.addLayout(gamemode_layout)

        # Parent item (shows only the file/folder)
        parent_item = QTreeWidgetItem(self.file_list)
        parent_item.setText(0, path)

        # Child item that receives the edit widget
        child_item = QTreeWidgetItem(parent_item)
        child_item.setFlags(child_item.flags() & ~Qt.ItemFlag.ItemIsSelectable)
        self.file_list.setItemWidget(child_item, 0, item_widget)

        parent_item.setExpanded(True)

        # Keep references
        parent_item.path = path
        parent_item.name_input = name_input
        parent_item.gamemode_checkbox = gamemode_checkbox

    def save_multiple(self):
        executor = self.executor_combo.currentData()
        selected_lang = self.language_input.currentText()
        if executor != "Linux":
            selected_lang = ""
        elif selected_lang == tr('PLACEHOLDER_FOR_LANGUAGE'):
            selected_lang = ""

        art_dir = Path.home() / "AppsFiles" / "Meganimus" / "art"
        art_dir.mkdir(parents=True, exist_ok=True)
        config_dir = Path.home() / "AppsFiles" / "Meganimus" / "config"
        config_dir.mkdir(parents=True, exist_ok=True)

        seen_names = set()

        # Name and duplicate validation
        for i in range(self.file_list.topLevelItemCount()):
            item = self.file_list.topLevelItem(i)
            name = item.name_input.text().strip()

            # Empty name
            if not name:
                QMessageBox.warning(self, tr("ERROR"), tr("MANDATORY_FIELDS_ERROR"))
                return

            safe_name = name.replace(" ", "_").lower()

            # Duplicate in own list
            if safe_name in seen_names:
                QMessageBox.warning(
                    self,
                    tr("ERROR"),
                    tr("DUPLICATE_NAME_IN_LIST", name=name)
                )
                return
            seen_names.add(safe_name)

            # Duplicate in filesystem
            portal_file = config_dir / f"portal-info-{safe_name}.json"
            if portal_file.exists():
                QMessageBox.warning(
                    self,
                    tr("ERROR"),
                    tr("PORTAL_IN_MULTIPLE_CREATE_ALREADY_EXISTS", name=name)
                )
                return

            # Test if you can write the file
            try:
                with open(portal_file, 'w', encoding="utf-8") as f:
                    json.dump({}, f)
                portal_file.unlink()
            except Exception as e:
                QMessageBox.critical(
                    self,
                    tr('ERROR'),
                    tr("NAME_INVALID_IN_MULTIPLE", name=name, error=str(e))
                )
                return

        for i in range(self.file_list.topLevelItemCount()):
            item = self.file_list.topLevelItem(i)
            path = item.path
            name = item.name_input.text().strip()
            safe_name = name.replace(" ", "_").lower()
            art_path = self.guess_portal_art(name)

            # Copy art to the art folder
            if art_path:
                art_path_obj = Path(art_path)
                if not str(art_path_obj).startswith(str(art_dir)):
                    try:
                        for old_file in art_dir.glob(f"{safe_name}.*"):
                            old_file.unlink()
                        art_extension = art_path_obj.suffix.lower()
                        art_filename = f"{safe_name}{art_extension}"
                        art_destination = art_dir / art_filename
                        shutil.copyfile(art_path_obj, art_destination)
                        art_path = str(art_destination)
                    except Exception:
                        art_path = ""

            portal_data = {
                "name": name,
                "executor": executor,
                "game_path": path,
                "art_path": art_path,
                "language": selected_lang,
                "use_gamemode": item.gamemode_checkbox.isChecked(),
                "env_vars": "",
                "portal_args": "",
                "show_fps": False,
                "fps_hud_type": "",
            }

            self.save_portal_data(portal_data)

        self.portals_saved.emit()
        self.accept()

    def save_portal_data(self, portal_data):
        config_dir = Path.home() / "AppsFiles" / "Meganimus" / "config"
        art_dir = Path.home() / "AppsFiles" / "Meganimus" / "art"
        config_dir.mkdir(parents=True, exist_ok=True)
        art_dir.mkdir(parents=True, exist_ok=True)

        safe_name = portal_data["name"].replace(" ", "_").lower()
        portal_file = config_dir / f"portal-info-{safe_name}.json"

        if portal_file.exists():
            return

        try:
            with open(portal_file, 'w', encoding="utf-8") as f:
                json.dump(portal_data, f, indent=4, ensure_ascii=False)
        except Exception:
            pass

class MultipleRemovePortalDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("MULTIPLE_PORTAL_REMOVER"))
        self.resize(600, 400)
        self.parent_ref = parent

        self.main_layout = QVBoxLayout(self)

        # Search bar
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText(tr("SEARCH"))
        self.search_input.textChanged.connect(self.update_portal_list)
        self.main_layout.addWidget(self.search_input)

        # Tabs for portals
        self.tabs = QTabWidget()
        self.main_layout.addWidget(self.tabs)
        # Fixed order of executors
        self.executor_order = ["Linux", "AzaharPlus", "Cemu", "Dolphin", "Duckstation", "MelonDS", "mGBA", "PCSX2", "PPSSPP", "RPCS3", "Ryubing"]
        self.executor_tabs = {}

        # Remove button
        self.remove_button = QPushButton(tr("REMOVE"))
        self.remove_button.clicked.connect(self.remove_selected_portals)
        self.main_layout.addWidget(self.remove_button)

        # Dictionary portal_name > checkbox
        self.portal_checkboxes = {}
        self.load_portals()

    def load_portals(self):
        """Loads all existing portals in alphabetical order, distributing them in tabs by executor."""
        config_dir = Path.home() / "AppsFiles" / "Meganimus" / "config"
        self.portal_checkboxes.clear()

        # Clears all existing tab layouts
        if hasattr(self, "executor_tabs"):
            for executor_data in self.executor_tabs.values():
                layout = executor_data["layout"]
                for i in reversed(range(layout.count())):
                    widget = layout.itemAt(i).widget()
                    if widget:
                        widget.setParent(None)

        # Sort files by name (alphabetical)
        portal_files = sorted(config_dir.glob("portal-info-*.json"), key=lambda p: p.stem.lower())

        for portal_file in portal_files:
            try:
                with open(portal_file, encoding="utf-8") as f:
                    portal_data = json.load(f)
                name = portal_data.get("name", portal_file.stem)
                executor = portal_data.get("executor", "Linux")
                checkbox = QCheckBox(name)
                checkbox.portal_file = portal_file
                checkbox.art_path = portal_data.get("art_path")

                # Prevents vertical/horizontal expansion
                checkbox.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)

                # Ensures all tabs exist in the fixed order
                if executor not in self.executor_tabs:
                    tab = QWidget()
                    tab_layout = QVBoxLayout(tab)

                    scroll = QScrollArea()
                    scroll.setWidgetResizable(True)
                    content = QWidget()
                    scroll_layout = QVBoxLayout(content)
                    scroll_layout.setContentsMargins(6, 6, 6, 6)
                    scroll_layout.setSpacing(4)
                    scroll_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
                    content.setLayout(scroll_layout)
                    scroll.setWidget(content)

                    tab_layout.addWidget(scroll)
                    self.tabs.addTab(tab, executor)
                    self.executor_tabs[executor] = {"tab": tab, "layout": scroll_layout}

                # Add to the executor tab
                self.executor_tabs[executor]["layout"].addWidget(checkbox)
                self.portal_checkboxes[name] = checkbox
            except Exception:
                continue

    def update_portal_list(self, text):
        """Filter portals by the text entered in the search."""
        text = text.lower()
        for name, checkbox in self.portal_checkboxes.items():
            checkbox.setVisible(text in name.lower())

    def remove_selected_portals(self):
        """Removes the selected portals."""
        to_remove = [cb for cb in self.portal_checkboxes.values() if cb.isChecked()]
        if not to_remove:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_PORTAL_SELECTED_MULTIPLE"))
            return

        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Warning)
        msg.setWindowTitle(tr("MULTIPLE_PORTAL_REMOVER"))
        msg.setText(tr("DELETE_PORTALS_CONFIRM_MESSAGE"))
        msg.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg.button(QMessageBox.StandardButton.Yes).setText(tr("YES_BUTTON"))
        msg.button(QMessageBox.StandardButton.No).setText(tr("NO_BUTTON"))

        if msg.exec() != QMessageBox.StandardButton.Yes:
            return

        for cb in to_remove:
            # Remove JSON
            try:
                if cb.portal_file.exists():
                    cb.portal_file.unlink()
            except Exception:
                pass
            # Remove artwork
            if cb.art_path:
                art_path = Path(cb.art_path)
                if art_path.exists() and art_path.is_file():
                    try:
                        art_path.unlink()
                    except Exception:
                        pass

        # Reload the list
        self.load_portals()
        if self.parent_ref:
            self.parent_ref.load_portals()
        
        self.accept()

class SettingsDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("MEGANIMUS_SETTINGS"))
        self.setMinimumSize(400, 340)

        self.settings = load_settings()
        layout = QVBoxLayout(self)

        # Qt Style choice
        style_layout = QHBoxLayout()
        style_label = QLabel(tr("QT_STYLE"))
        self.style_combo = QComboBox()
        self.style_combo.addItems(QStyleFactory.keys())
        default_style = self.settings.get("qt_style", "Oxygen")
        if default_style in QStyleFactory.keys():
            self.style_combo.setCurrentText(default_style)
        style_layout.addWidget(style_label)
        style_layout.addWidget(self.style_combo)
        layout.addLayout(style_layout)

        # Language choice
        lang_layout = QHBoxLayout()
        lang_label = QLabel(tr("LANGUAGE"))
        self.lang_combo = QComboBox()
        self.lang_combo.addItems(SUPPORTED_LANGUAGES.keys())
        saved_lang = self.settings.get("language", LANG)
        lang_codes = list(SUPPORTED_LANGUAGES.values())
        if saved_lang in lang_codes:
            self.lang_combo.setCurrentIndex(lang_codes.index(saved_lang))
        else:
            self.lang_combo.setCurrentIndex(0)
        lang_layout.addWidget(lang_label)
        lang_layout.addWidget(self.lang_combo)
        layout.addLayout(lang_layout)

        # Hide Portal images
        images_layout = QHBoxLayout()
        self.hide_images_checkbox = QCheckBox(tr("HIDE_PORTAL_IMAGES"))
        self.hide_images_checkbox.setChecked(self.settings.get("hide_portal_images", False))
        images_layout.addWidget(self.hide_images_checkbox)
        layout.addLayout(images_layout)

        # Executors section
        executors_label = QLabel(tr("EXECUTORS"))
        executors_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        layout.addWidget(executors_label)

        # Creates the QTabWidget for the executors
        tabs = QTabWidget()
        layout.addWidget(tabs)

        # Configuring executors and options
        self.executors_config = {
            "AzaharPlus": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("AppImage", "AppImage")
                ],
                "default_command": {
                    "Snap": "snap run azaharplus-emulator",
                    "Flatpak": "",
                }
            },
            "Cemu": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    ("AppImage", "AppImage")
                ],
                "default_command": {
                    "Snap": "snap run cemu-emulator",
                    "Flatpak": "flatpak run info.cemu.Cemu",
                }
            },
            "Dolphin": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    ("AppImage", "AppImage")
                ],
                "default_command": {
                    "Snap": "snap run dolphin-emulator-kyu",
                    "Flatpak": "flatpak run org.DolphinEmu.dolphin-emu",
                }
            },
            "Duckstation": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    ("AppImage", "AppImage")
                ],
                "default_command": {
                    "Snap": "snap run duckstation-gpl",
                    "Flatpak": "flatpak run org.duckstation.DuckStation",
                }
            },
            "MelonDS": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    ("AppImage", "AppImage")
                ],
                "default_command": {
                    "Snap": "snap run melonds-emulator",
                    "Flatpak": "flatpak run net.kuribo64.melonDS",
                }
            },
            "mGBA": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    ("AppImage", "AppImage")
                ],
                "default_command": {
                    "Snap": "snap run mgba-emulator",
                    "Flatpak": "flatpak run io.mgba.mGBA",
                }
            },
            "PCSX2": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    ("AppImage", "AppImage")
                ],
                "default_command": {
                    "Snap": "snap run pcsx2-emulator",
                    "Flatpak": "flatpak run net.pcsx2.PCSX2",
                }
            },
            "PPSSPP": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    ("AppImage", "AppImage")
                ],
                "default_command": {
                    "Snap": "snap run ppsspp-emulator",
                    "Flatpak": "flatpak run org.ppsspp.PPSSPP",
                }
            },
            "RPCS3": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Flatpak", "Flatpak"),
                    ("AppImage", "AppImage")
                ],
                "default_command": {
                    "Snap": "snap run rpcs3-emulator",
                    "Flatpak": "flatpak run net.rpcs3.RPCS3",
                }
            },
            "Ryubing": {
                "options": [
                    (tr("SELECT_VERSION"), "OFF"),
                    ("Snap", "Snap"),
                    ("Flatpak", "Flatpak"),
                    ("AppImage", "AppImage")
                ],
                "default_command": {
                    "Snap": "snap run ryubing-emulator",
                    "Flatpak": "flatpak run io.github.ryubing.Ryujinx",
                }
            },
        }

        # Store widgets for each executor
        self.executor_widgets = {}

        for executor_name, config in self.executors_config.items():
            # Executor tab
            tab = QWidget()
            tab_layout = QVBoxLayout(tab)

            # Version
            version_layout = QHBoxLayout()
            version_label = QLabel(tr("EXECUTOR_VERSION"))
            combo = QComboBox()
            for text, value in config["options"]:
                combo.addItem(text, userData=value)
            version_layout.addWidget(version_label)
            version_layout.addWidget(combo, stretch=1)
            tab_layout.addLayout(version_layout)

            # Command
            command_layout = QHBoxLayout()
            command_label = QLabel(tr("EXECUTOR_COMMAND"))
            path_input = QLineEdit()
            command_layout.addWidget(command_label)
            command_layout.addWidget(path_input, stretch=1)
            tab_layout.addLayout(command_layout)

            # Buttons
            button_layout = QHBoxLayout()
            start_btn = QPushButton(tr("START"))
            browse_btn = QPushButton(tr("BROWSE_BUTTON"))
            button_layout.addWidget(start_btn)
            button_layout.addWidget(browse_btn)
            tab_layout.addLayout(button_layout)

            # Add tab to tab widget
            tabs.addTab(tab, executor_name)

            # Save widgets for later access
            self.executor_widgets[executor_name] = {
                "combo": combo,
                "path_input": path_input,
                "start_btn": start_btn,
                "browse_btn": browse_btn
            }

            # Connects signals
            combo.currentIndexChanged.connect(
                lambda i, r=executor_name, c=combo: self.update_executor_command(r, c.itemData(i))
            )
            start_btn.clicked.connect(lambda _, r=executor_name: self.start_executor(r))
            browse_btn.clicked.connect(lambda _, r=executor_name: self.browse_executor(r))

            # Initializes saved values
            saved_executor = self.settings.get(f"{executor_name.lower()}_executor", "OFF")
            saved_command = self.settings.get(f"{executor_name.lower()}_command", "")
            index = next((i for i in range(combo.count()) if combo.itemData(i) == saved_executor), 0)
            combo.setCurrentIndex(index)
            self.update_executor_command(executor_name, combo.itemData(index), saved_command)

        # Save Button
        save_btn = QPushButton(tr("SAVE_BUTTON"))
        save_btn.clicked.connect(self.save_and_close)
        layout.addWidget(save_btn, alignment=Qt.AlignmentFlag.AlignRight)

    def update_executor_command(self, executor_name, choice, saved_command=""):
        widgets = self.executor_widgets[executor_name]
        path_input = widgets["path_input"]
        browse_btn = widgets["browse_btn"]

        default_cmds = self.executors_config[executor_name].get("default_command", {})

        if choice in default_cmds:
            path_input.setText(default_cmds[choice])
            path_input.setReadOnly(True)
            browse_btn.setEnabled(False)
        elif choice == "AppImage":
            path_input.setText(saved_command if saved_command else "")
            path_input.setReadOnly(False)
            browse_btn.setEnabled(True)
        else:  # OFF / SELECT_VERSION
            path_input.setText("")
            path_input.setReadOnly(True)
            browse_btn.setEnabled(False)

    def browse_executor(self, executor_name):
        widgets = self.executor_widgets[executor_name]
        path, _ = QFileDialog.getOpenFileName(self, tr("SELECT_FILE"))
        if path:
            widgets["path_input"].setText(path)

    def start_executor(self, executor_name):
        path_input = self.executor_widgets[executor_name]["path_input"]
        command = path_input.text().strip()

        if not command:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_COMMAND_DEFINED"))
            return

        try:
            # Runs without crashing the UI
            subprocess.Popen(command, shell=True)
        except Exception as e:
            QMessageBox.critical(self, tr("APP_NAME"), f"{tr('FAILED_TO_START')}: {e}")

    def save_and_close(self):
        self.settings["qt_style"] = self.style_combo.currentText()
        selected_index = self.lang_combo.currentIndex()
        self.settings["language"] = list(SUPPORTED_LANGUAGES.values())[selected_index]
        self.settings["hide_portal_images"] = self.hide_images_checkbox.isChecked()

        # Save all executors dynamically
        for executor_name, widgets in self.executor_widgets.items():
            self.settings[f"{executor_name.lower()}_executor"] = widgets["combo"].currentData()
            self.settings[f"{executor_name.lower()}_command"] = widgets["path_input"].text()

        save_settings(self.settings)
        QMessageBox.information(
            self,
            tr("APP_NAME"),
            tr("SETTINGS_SAVED_RESTART")
        )
        self.accept()

class Meganimus(QMainWindow):
    def __init__(self):
        super().__init__()
        settings = load_settings()
        self.hide_portal_images = settings.get("hide_portal_images", False)
        wanted = settings.get("qt_style")

        self.settings = QSettings("Kyuyrii", "Meganimus")

        size = self.settings.value("windowSize")
        if size:
            self.resize(size)
        else:
            self.resize(780, 640)

        # Only apply style if available
        if wanted and wanted in QStyleFactory.keys():
            QApplication.setStyle(wanted)
        self.setWindowTitle(tr('APP_NAME'))
        self.setMinimumSize(300, 160)
        self.portal_process = None

        # Icon
        local_icons = ['meganimus.svg', 'Meganimus.svg']
        icon_set = False
        for icon_file in local_icons:
            if Path(icon_file).exists():
                self.setWindowIcon(QIcon(icon_file))
                icon_set = True
                break
        if not icon_set:
            for name in ['meganimus', 'Meganimus', 'applications-all']:
                icon = QIcon.fromTheme(name)
                if not icon.isNull():
                    self.setWindowIcon(icon)
                    break

        self.meganimus_dir = Path.home() / "AppsFiles" / "Meganimus"
        self.setup_directories()

        # Menubar
        menu_bar = self.menuBar()

        # Creation of actions
        self.add_portal_action = QAction(QIcon.fromTheme("list-add"), tr('CREATE_PORTAL'), self)
        self.add_portal_action.triggered.connect(self.add_portal)

        self.multiple_create_portals_action = QAction(tr('MULTIPLE_PORTAL_CREATOR'), self)
        self.multiple_create_portals_action.triggered.connect(self.multiple_create_portals)

        self.multiple_remove_portals_action = QAction(tr("MULTIPLE_PORTAL_REMOVER"), self)
        self.multiple_remove_portals_action.triggered.connect(self.multiple_remove_portals)

        self.edit_portal_action = QAction(QIcon.fromTheme("document-edit"), tr('MODIFY_PORTAL'), self)
        self.edit_portal_action.triggered.connect(self.edit_portal)

        self.run_action = QAction(QIcon.fromTheme("media-playback-start"), tr('START_PORTAL'), self)
        self.run_action.triggered.connect(self.start_selected_portal)

        self.stop_execution_action = QAction(QIcon.fromTheme("media-playback-stop"), tr('STOP_PORTAL'), self)
        self.stop_execution_action.triggered.connect(self.stop_execution)

        self.transfer_heroes_action = QAction(tr('TRANSFER_HEROES'), self)
        self.transfer_heroes_action.triggered.connect(self.open_transfer_heroes)

        self.settings_action = QAction(tr("MEGANIMUS_SETTINGS"), self)
        self.settings_action.triggered.connect(self.open_settings)

        self.about_action = QAction(tr("ABOUT_MEGANIMUS"), self)
        self.about_action.triggered.connect(self.show_about)

        # Menus
        portal_menu = menu_bar.addMenu(tr("PORTAL"))
        portal_menu.addAction(self.multiple_create_portals_action)
        portal_menu.addAction(self.multiple_remove_portals_action)

        transfer_menu = menu_bar.addMenu(tr("TRANSFER"))
        transfer_menu.addAction(self.transfer_heroes_action)

        extras_menu = menu_bar.addMenu(tr("EXTRAS"))
        extras_menu.addAction(self.settings_action)
        extras_menu.addAction(self.about_action)

        # Toolbar
        self.toolbar = QToolBar()
        self.addToolBar(Qt.ToolBarArea.BottomToolBarArea, self.toolbar)
        self.toolbar.setMovable(False)
        self.toolbar.setFloatable(False)
        self.toolbar.setIconSize(QSize(32, 32))

        # Keeps only main shares
        self.toolbar.addAction(self.add_portal_action)
        self.toolbar.addAction(self.edit_portal_action)
        self.toolbar.addAction(self.run_action)
        self.toolbar.addAction(self.stop_execution_action)

        # Search bar
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText(tr("SEARCH"))
        self.search_bar.textChanged.connect(self.filter_portals)

        search_widget_action = QWidgetAction(self)
        search_widget_action.setDefaultWidget(self.search_bar)
        self.toolbar.addAction(search_widget_action)

        # Central Widget
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.main_layout = QVBoxLayout()
        self.central_widget.setLayout(self.main_layout)
        self.main_layout.setContentsMargins(8, 0, 8, 0)

        self.portal_tree = QTreeWidget()
        self.portal_tree.setColumnCount(1)
        self.portal_tree.setHeaderHidden(True)
        self.portal_tree.setIconSize(QSize(420, int(420 * (620 / 1920))))
        self.portal_tree.setRootIsDecorated(True)
        self.portal_tree.setIndentation(20)
        self.portal_tree.setAlternatingRowColors(True)
        self.portal_tree.setUniformRowHeights(False)
        self.portal_tree.setExpandsOnDoubleClick(True)
        self.portal_tree.setAllColumnsShowFocus(True)
        self.main_layout.addWidget(self.portal_tree)

        self.platform_items = {}
        for platform in ["Linux", "AzaharPlus", "Cemu", "Dolphin", "Duckstation", "MelonDS", "mGBA", "PCSX2", "PPSSPP", "RPCS3", "Ryubing"]:
            parent_item = QTreeWidgetItem([platform])
            parent_item.setFirstColumnSpanned(True)
            font = QFont()
            font.setBold(True)
            parent_item.setFont(0, font)
            self.portal_tree.addTopLevelItem(parent_item)
            self.platform_items[platform] = parent_item

        self.load_portals()
        atexit.register(self.kill_portal_process_on_exit)
        self.transfer_successful = False

    def multiple_create_portals(self):
        dialog = MultipleCreatePortalsDialog(self)
        dialog.portals_saved.connect(self.load_portals)
        dialog.exec()

    def multiple_remove_portals(self):
        dialog = MultipleRemovePortalDialog(self)
        dialog.finished.connect(self.load_portals)
        dialog.exec()

    def closeEvent(self, event):
        self.settings.setValue("windowSize", self.size())
        # Checks if the title contains the string "PORTAL_STARTED"
        if self.windowTitle().startswith(tr("PORTAL_STARTED", portal_name="").split("{portal_name}")[0].strip()):
            reply = QMessageBox.question(
                self,
                tr("APP_NAME"),
                tr("CONFIRM_CLOSE_MESSAGE"),
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.Yes:
                self.stop_execution()
                event.accept()
            else:
                event.ignore()
        else:
            event.accept()

    def stop_execution(self):
        self.setWindowTitle(tr('APP_NAME'))

        if hasattr(self, "portal_process") and self.portal_process:
            if self.portal_process.poll() is None:
                try:
                    # Kill children of the process you started
                    parent = psutil.Process(self.portal_process.pid)
                    for child in parent.children(recursive=True):
                        try:
                            child.kill()
                            print(tr("STOP_PROCESS_SUCCESS", pid=child.pid))
                        except Exception as e:
                            print(tr("STOP_KILL_ERROR", pid=child.pid, error=e))

                    # Then kill the game process itself
                    self.portal_process.kill()
                    print(tr("STOP_PROCESS_SUCCESS", pid=self.portal_process.pid, exe=self.last_game))

                except Exception as e:
                    print(tr("STOP_KILL_ERROR", error=e))
            else:
                print(tr("STOP_NO_PROCESS_FOUND"))
        else:
            print(tr("STOP_NO_PORTAL_ACTIVE"))

        # Cleans internal references
        self.portal_process = None
        self.last_game = None
        self.real_portal_process = None

    def kill_portal_process_on_exit(self):
        if hasattr(self, "portal_process") and self.portal_process and self.portal_process.poll() is None:
            print(tr("MEGANIMUS_CLOSED"))
            self.stop_execution()

    def setup_directories(self):
        """Creates the main Meganimus directory structure using pathlib with real folder names."""
        base = Path(self.meganimus_dir)
        subdirs = [
            base / "config",
            base / "art"
        ]

        for subdir in subdirs:
            subdir.mkdir(parents=True, exist_ok=True)

    def filter_portals(self, text):
        """Filters portals in QTreeWidget and expands categories with matching items."""
        text = text.lower()

        for platform_item in self.platform_items.values():
            any_child_visible = False
            for i in range(platform_item.childCount()):
                child = platform_item.child(i)
                portal_name = child.text(0).lower()
                visible = text in portal_name
                child.setHidden(not visible)
                if visible:
                    any_child_visible = True
            
            # Expands the category if any children are visible
            platform_item.setExpanded(any_child_visible)

    def load_portals(self):
        """Loads portal data and preserves selection and filter."""

        # Saves scroll, selection and search text
        scroll_pos = self.portal_tree.verticalScrollBar().value()
        selected_item = self.portal_tree.currentItem()
        selected_name = selected_item.text(0) if selected_item else None
        filter_text = self.search_bar.text() if hasattr(self, "search_bar") else ""

        # Cleans all children
        for platform_item in self.platform_items.values():
            platform_item.takeChildren()

        config_dir = Path(self.meganimus_dir) / "config"
        if not config_dir.exists():
            return

        portals = []
        for file_path in config_dir.glob("portal-info-*.json"):
            try:
                with file_path.open('r', encoding='utf-8') as f:
                    portal_data = json.load(f)
                    portals.append((portal_data, file_path))
            except (IOError, json.JSONDecodeError) as e:
                print(tr("ERROR_LOADING_FILE", file=file_path, error=e))

        portals.sort(key=lambda g: g[0].get('name', '').casefold())

        # Add the portals
        for portal_data, file_path in portals:
            item = self.add_portal_to_list(portal_data)
            item.portal_file_path = file_path

        # Reapply filter, if applicable.
        if filter_text:
            self.filter_portals(filter_text)

        # Expands or collapses categories depending on whether they have children
        for platform_item in self.platform_items.values():
            if platform_item.childCount() > 0:
                platform_item.setExpanded(True)
                platform_item.setHidden(False)   # Ensures it appears
            else:
                platform_item.setHidden(True)    # Hide if empty

        # Restores the selection, if still visible
        if selected_name:
            for platform_item in self.platform_items.values():
                for i in range(platform_item.childCount()):
                    child = platform_item.child(i)
                    if child.text(0) == selected_name and not child.isHidden():
                        self.portal_tree.setCurrentItem(child)
                        break

        # Restores scroll
        self.portal_tree.verticalScrollBar().setValue(scroll_pos)

    def add_portal(self):
        dialog = AddPortalDialog(self)
        dialog.portal_saved.connect(self.load_portals)
        dialog.exec()

    def edit_portal(self):
        portal_name = self.get_selected_portal()
        if not portal_name:
            QMessageBox.warning(self, tr("APP_NAME"), tr("NO_PORTAL_SELECTED_ERROR"))
            return

        config_dir = Path(self.meganimus_dir) / "config"
        safe_portal_name = portal_name.replace(" ", "_").lower()
        portal_file_path = config_dir / f"portal-info-{safe_portal_name}.json"

        try:
            with portal_file_path.open('r', encoding='utf-8') as f:
                portal_data = json.load(f)
        except (IOError, json.JSONDecodeError):
            QMessageBox.critical(self, tr('ERROR'), tr('PORTAL_INFO_ERROR', name=portal_name))
            return

        dialog = AddPortalDialog(self, portal_data)
        dialog.portal_saved.connect(self.load_portals)
        dialog.exec()

    def start_portal(self, item_or_name):
        if self.windowTitle().startswith(tr("PORTAL_STARTED", portal_name="").split("{portal_name}")[0].strip()):
            reply = QMessageBox.question(
                self,
                tr("APP_NAME"),
                tr("PORTAL_ALREADY_ACTIVE"),
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )

            if reply == QMessageBox.StandardButton.Yes:
                self.stop_execution()
            else:
                return

        if not item_or_name:
            QMessageBox.warning(self, tr('APP_NAME'), tr('NO_PORTAL_SELECTED_ERROR'))
            return

        portal_name = item_or_name.text() if isinstance(item_or_name, QListWidgetItem) else str(item_or_name)
        print(tr('STARTING_PORTAL', name=portal_name))

        config_dir = Path(self.meganimus_dir) / "config"
        safe_portal_name = portal_name.replace(" ", "_").lower()
        portal_file_path = config_dir / f"portal-info-{safe_portal_name}.json"

        try:
            with portal_file_path.open('r', encoding='utf-8') as f:
                portal_data = json.load(f)
            print(tr('PORTAL_INFO_LOADED', name=portal_name))

            game_path_full = Path(portal_data['game_path'])

            # Initialize env with system copy
            env = os.environ.copy()

            # Executor
            executor = portal_data.get("executor", "Linux")

            # Language/Locale > only applies if using Linux
            if executor == "Linux":
                language = portal_data.get('language', '').strip()
                if language:
                    try:
                        locale_code = language.split("(")[1].replace(")", "").strip() if "(" in language and ")" in language else language
                        env["LC_ALL"] = locale_code
                        env["LANG"] = locale_code
                        env["LANGUAGE"] = locale_code
                    except Exception as e:
                        print(tr("LANGUAGE_SET_ERROR", error=e))

            # FPS HUDs > Linux only
            if executor == "Linux":
                show_fps = portal_data.get('show_fps', False)
                fps_hud_type = portal_data.get('fps_hud_type', '')
                if show_fps:
                    if fps_hud_type == "FPS_GALLIUM_HUD":
                        env["GALLIUM_HUD"] = "fps+cpu,frametime"
                    #elif fps_hud_type == "FPS_MANGOHUD":
                    #    env["MANGOHUD"] = "1"
                    #    env["MANGOHUD_CONFIG"] = "fps_only"

            # Extra variables
            env_vars_str = portal_data.get('env_vars', '').strip()
            if env_vars_str:
                for item in env_vars_str.split():
                    if "=" in item:
                        key, value = item.split("=", 1)
                        env[key] = value

            # Gamemode
            use_gamemode = portal_data.get('use_gamemode', True)

            # Game arguments
            portal_args = portal_data.get('portal_args', '').strip()
            portal_args_list = portal_args.split() if portal_args else []

            # Executor
            executor = portal_data.get("executor", "Linux")
            settings = load_settings()

            # Executor configuration
            executors_config = {
                "Linux": {"type": "direct"},
                "AzaharPlus": {
                    "AppImage": {"type": "direct", "extra_flags": ["-f"]},
                    "Snap": {"type": "command", "extra_flags": ["-f"]},
                    "Flatpak": {"type": "command", "extra_flags": ["-f"]},
                },
                "Cemu": {
                    "AppImage": {"type": "direct", "extra_flags": ["-f", "-g"]},
                    "Snap": {"type": "command", "extra_flags": ["-f", "-g"]},
                    "Flatpak": {"type": "command", "extra_flags": ["-f", "-g"]},
                },
                "Dolphin": {
                    "AppImage": {"type": "direct", "extra_flags": ["--batch", "-e"]},
                    "Snap": {"type": "command", "extra_flags": ["--batch", "-e"]},
                    "Flatpak": {"type": "command", "extra_flags": ["--batch", "-e"]},
                },
                "Duckstation": {
                    "AppImage": {"type": "direct", "extra_flags": ["-fullscreen"]},
                    "Snap": {"type": "command", "extra_flags": ["-fullscreen"]},
                    "Flatpak": {"type": "command", "extra_flags": ["-fullscreen"]},
                },
                "MelonDS": {
                    "AppImage": {"type": "direct", "extra_flags": ["-f"]},
                    "Snap": {"type": "command", "extra_flags": ["-f"]},
                    "Flatpak": {"type": "command", "extra_flags": ["-f"]},
                },
                "mGBA": {
                    "AppImage": {"type": "direct", "extra_flags": ["-f"]},
                    "Snap": {"type": "command", "extra_flags": ["-f"]},
                    "Flatpak": {"type": "command", "extra_flags": ["-f"]},
                },
                "PCSX2": {
                    "AppImage": {"type": "direct", "extra_flags": ["-fullscreen"]},
                    "Snap": {"type": "command", "extra_flags": ["-fullscreen"]},
                    "Flatpak": {"type": "command", "extra_flags": ["-fullscreen"]},
                },
                "PPSSPP": {
                    "AppImage": {"type": "direct", "extra_flags": ["--fullscreen", "--pause-menu-exit"]},
                    "Snap": {"type": "command", "extra_flags": ["--fullscreen", "--pause-menu-exit"]},
                    "Flatpak": {"type": "command", "extra_flags": ["--fullscreen", "--pause-menu-exit"]},
                },
                "RPCS3": {
                    "AppImage": {"type": "direct", "extra_flags": ["--no-gui", "--fullscreen"]},
                    "Snap": {"type": "command", "extra_flags": ["--no-gui", "--fullscreen"]},
                    "Flatpak": {"type": "command", "extra_flags": ["--no-gui", "--fullscreen"]},
                },
                "Ryubing": {
                    "AppImage": {"type": "direct", "extra_flags": ["-f"]},
                    "Snap": {"type": "command", "extra_flags": ["-f"]},
                    "Flatpak": {"type": "command", "extra_flags": ["-f"]},
                },
            }

            def build_executor_command(executor, game_path):
                cfg = executors_config.get(executor, {"type": "direct"})

                # Simple case: direct executable
                if cfg.get("type") == "direct":
                    return [str(game_path)]

                # If the runner has settings for Snap/Flatpak/AppImage
                executor_type = settings.get(f"{executor.lower()}_executor", "OFF")
                if executor_type in cfg:
                    executor_command_str = settings.get(f"{executor.lower()}_command", "")
                    if not executor_command_str and cfg[executor_type]["type"] == "command":
                        QMessageBox.warning(None, tr("APP_NAME"), tr("EXECUTOR_COMMAND_NOT_SET"))
                        return None
                    cmd = executor_command_str.split() if executor_command_str else []
                    cmd += cfg[executor_type]["extra_flags"]
                    cmd.append(str(game_path))
                    return cmd

                # If it does not have a valid executor_type, it falls into the direct executable
                return [str(game_path)]

            executor_command = build_executor_command(executor, game_path_full)
            if executor_command is None:
                return

            # Gamemode in front, if enabled
            if use_gamemode and shutil.which("gamemoderun"):
                executor_command = [shutil.which("gamemoderun")] + executor_command

            # Final command
            command = executor_command + portal_args_list

            # For final command debugging
            debug_command = []
            for var in ["LC_ALL", "LANG", "LANGUAGE", "GALLIUM_HUD"]:
                if var in env:
                    debug_command.append(f"{var}={env[var]}")

            if env_vars_str:
                for item in env_vars_str.split():
                    if '=' in item:
                        debug_command.append(item)

            debug_command += command
            print(tr('RUNNING_COMMAND', command=" ".join(debug_command)))

            self.portal_process = subprocess.Popen(
                command,
                env=env,
                cwd=str(game_path_full.parent),
                stdout=sys.stdout,
                stderr=sys.stderr
            )

            self.last_game = str(game_path_full)
            self.setWindowTitle(tr('PORTAL_STARTED', portal_name=portal_name))

            # Short wait for spawn
            time.sleep(2)

            # Real process capture
            try:
                parent = psutil.Process(self.portal_process.pid)
                children = parent.children(recursive=True)
                self.real_portal_process = children[-1] if children else None
                if self.real_portal_process:
                    print(tr("DEBUG_REAL_PORTAL_INITIATED", pid=self.real_portal_process.pid))
            except psutil.NoSuchProcess:
                self.real_portal_process = None

        except (IOError, json.JSONDecodeError):
            QMessageBox.critical(self, tr('ERROR'), tr('PORTAL_INFO_ERROR', name=portal_name))
        except Exception as e:
            QMessageBox.critical(self, tr('ERROR'), tr('PORTAL_START_ERROR', error=str(e)))

    def start_selected_portal(self):
        portal_name = self.get_selected_portal()
        if not portal_name:
            QMessageBox.warning(self, tr('APP_NAME'), tr('NO_PORTAL_SELECTED_ERROR'))
            return

        self.start_portal(portal_name)

    def get_selected_portal(self):
        item = self.portal_tree.currentItem()
        if item and item.parent():  # Ensures that it is not the platform node
            return item.text(0)
        return None

    def add_portal_to_list(self, portal_data):
        portal_name = portal_data['name']
        executor = portal_data.get("executor", "Linux")  # Linux standard

        item = QTreeWidgetItem([
            portal_name,
        ])

        # After creating the item
        font = QFont()
        font.setBold(True)
        item.setFont(0, font)  # 0 is the portal name column

        # Large icon scaled proportionally
        art_path = portal_data.get('art_path')
        if art_path and not getattr(self, "hide_portal_images", False):
            art_file = Path(art_path)
            if art_file.exists():
                pixmap = QPixmap(str(art_file))
                if not pixmap.isNull():
                    # Resizes to the size of the QTreeWidget icon
                    icon_size = self.portal_tree.iconSize()
                    pixmap = pixmap.scaled(
                        icon_size,
                        Qt.AspectRatioMode.KeepAspectRatio,
                        Qt.TransformationMode.SmoothTransformation
                    )
                    icon = QIcon()
                    icon.addPixmap(pixmap, QIcon.Mode.Normal, QIcon.State.Off)
                    icon.addPixmap(pixmap, QIcon.Mode.Selected, QIcon.State.Off)
                    icon.addPixmap(pixmap, QIcon.Mode.Active, QIcon.State.Off)
                    icon.addPixmap(pixmap, QIcon.Mode.Disabled, QIcon.State.Off)
                    item.setIcon(0, icon)

        # Add to correct platform node
        parent_item = self.platform_items.get(executor, self.platform_items["Linux"])
        parent_item.addChild(item)

        return item

    def open_transfer_heroes(self):
        dialog = SteamGridDBApp(self)
        dialog.exec()

    def open_settings(self):
        dlg = SettingsDialog(self)
        dlg.exec()

    def show_about(self):
        QMessageBox.about(
        self,
        tr('ABOUT_MEGANIMUS'),
        tr('ABOUT_TEXT_HTML')
    )

# API key
API_DIR = Path.home() / "AppsFiles" / "Meganimus" / "config"
API_FILE = API_DIR / "sgdb_apikey.json"

# Heroes images / SteamGridDB
HEROES_DIR = Path.home() / "AppsFiles" / "Meganimus" / "heroes"
HEROES_DIR.mkdir(parents=True, exist_ok=True)

# ===================== SGDB: heroes worker (thread) =====================
class HeroesLoader(QThread):
    finished = pyqtSignal(list)  # List of heroes [{id, url, img_data}, ...]
    error = pyqtSignal(str)
    progress = pyqtSignal(int)   # 0 to 100%

    def __init__(self, api_key, game_id):
        super().__init__()
        self.api_key = api_key
        self.game_id = game_id

    def run(self):
        try:
            headers = {"Authorization": f"Bearer {self.api_key}"}
            url = f"https://www.steamgriddb.com/api/v2/heroes/game/{self.game_id}"
            resp = requests.get(url, headers=headers, timeout=20)
            resp.raise_for_status()
            data = resp.json().get("data", [])

            results = []
            total = len(data)

            for idx, hero in enumerate(data):
                # Attempt to get thumbnail; fallback to full URL
                thumb_url = (
                    hero.get("thumb")
                    or hero.get("thumb_url")
                    or (hero.get("thumbs")[0] if isinstance(hero.get("thumbs"), list) and hero["thumbs"] else None)
                    or hero.get("url")
                )
                img_data = None
                if thumb_url:
                    try:
                        rt = requests.get(thumb_url, timeout=15)
                        rt.raise_for_status()
                        img_data = rt.content
                    except Exception:
                        img_data = None  # If it fails, continue

                results.append({
                    "id": hero.get("id"),
                    "url": hero.get("url"),
                    "img_data": img_data
                })

                # Updates the progress bar
                if total > 0:
                    self.progress.emit(int((idx + 1) / total * 100))

            self.finished.emit(results)

        except Exception as e:
            self.error.emit(tr("HEROES_LOAD_ERROR", error=str(e)))

# ===================== SGDB: Transfer heroes window =====================
class SteamGridDBApp(QDialog):
    def __init__(self, parent):
        super().__init__(parent)
        self.api_key = None
        self.headers = None
        self.results = []
        self.heroes = []
        self.selected_game = None

        self.setWindowTitle(tr('TRANSFER_HEROES_TITLE'))
        self.resize(750, 480)
        self.setMinimumSize(300, 250)

        main_layout = QVBoxLayout(self)
        self.setLayout(main_layout)

        # API Key
        key_row = QHBoxLayout()
        key_row.addWidget(QLabel(tr('SGDB_API_KEY_LABEL')))
        self.key_input = QLineEdit()
        self.key_input.setEchoMode(QLineEdit.EchoMode.Password)
        key_row.addWidget(self.key_input)

        save_btn = QPushButton(tr('SAVE_BUTTON'))
        save_btn.clicked.connect(self.save_api_key)
        save_btn.setAutoDefault(False)  # Prevents being triggered by Enter
        save_btn.setDefault(False)      # Prevents being triggered by Enter
        key_row.addWidget(save_btn)
        main_layout.addLayout(key_row)

        # Lists (results and images) with resizable splitter
        self.games_panel = self._make_radio_panel_for_games()

        # Image Container Using QScrollArea
        self.images_container = QWidget()
        self.images_layout = QVBoxLayout(self.images_container)
        self.images_layout.setContentsMargins(6, 6, 6, 6)
        self.images_layout.setSpacing(4)
        self.images_layout.setAlignment(Qt.AlignmentFlag.AlignTop)  # Force items to the top

        self.images_scroll = QScrollArea()
        self.images_scroll.setWidgetResizable(True)
        self.images_scroll.setWidget(self.images_container)

        # Creates horizontal splitter
        body_splitter = QSplitter(Qt.Orientation.Horizontal)
        body_splitter.addWidget(self.games_panel["scroll"])
        body_splitter.addWidget(self.images_scroll)

        # Equal initial width for both sides
        body_splitter.setSizes([1, 1])

        # Prevents any side from disappearing when dragging
        body_splitter.setChildrenCollapsible(False)

        # Adds to main layout
        main_layout.addWidget(body_splitter)

        # Search
        search_row = QHBoxLayout()
        self.search_input = QLineEdit()
        search_row.addWidget(self.search_input)

        search_btn = QPushButton(tr('SEARCH'))
        search_btn.clicked.connect(self.search_game)
        self.search_input.returnPressed.connect(self.search_game)
        search_row.addWidget(search_btn)
        main_layout.addLayout(search_row)

        # Transfer button
        self.transfer_button = QPushButton(tr('TRANSFER'))
        self.transfer_button.setEnabled(False)
        self.transfer_button.clicked.connect(self.transfer_images)
        self.transfer_button.setAutoDefault(False)  # Prevents being triggered by Enter
        self.transfer_button.setDefault(False)      # Prevents being triggered by Enter
        main_layout.addWidget(self.transfer_button)

        # Progress bar always visible
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)  # Starts at 0%
        main_layout.addWidget(self.progress_bar)

        # Load API key if it exists
        self.load_api_key()

    # API key persistence
    def load_api_key(self):
        try:
            if API_FILE.exists():
                with API_FILE.open("r", encoding="utf-8") as f:
                    try:
                        data = json.load(f)
                        self.api_key = data.get("apikey", "").strip()
                    except Exception:
                        # Fallback: If not valid JSON, read as plain text
                        f.seek(0)
                        self.api_key = f.read().strip()
                self.key_input.setText(self.api_key)
                self.headers = {"Authorization": f"Bearer {self.api_key}"}
        except Exception:
            pass

    def save_api_key(self):
        key = self.key_input.text().strip()
        if not key:
            QMessageBox.warning(self, tr('APP_NAME'), tr('API_KEY_REQUIRED_SGDB'))
            return
        try:
            API_DIR.mkdir(parents=True, exist_ok=True)
            with API_FILE.open("w", encoding="utf-8") as f:
                json.dump({"apikey": key}, f, indent=2, ensure_ascii=False)
            self.api_key = key
            self.headers = {"Authorization": f"Bearer {self.api_key}"}
            QMessageBox.information(self, tr('TRANSFER_HEROES'), tr('API_KEY_SAVED'))
        except Exception as e:
            QMessageBox.critical(self, tr("ERROR"), tr("API_KEY_SAVE_ERROR", error=str(e)))

    # Search games
    def search_game(self):
        """Searches for games in SteamGridDB and updates the radio panel."""
        if not self.headers:
            QMessageBox.warning(self, tr('APP_NAME'), tr('API_KEY_SAVE_FIRST'))
            return

        term = self.search_input.text().strip()
        if not term:
            QMessageBox.warning(self, tr('APP_NAME'), tr('ENTER_GAME_NAME'))
            return

        # Clear selection and UI before fetching
        self.selected_game = None
        # Clear the image container
        for i in reversed(range(self.images_layout.count())):
            widget = self.images_layout.itemAt(i).widget()
            if widget:
                widget.setParent(None)
        self.transfer_button.setEnabled(False)
        self._clear_radio_panel(self.games_panel)

        # API Search
        try:
            url = f"https://www.steamgriddb.com/api/v2/search/autocomplete/{term}"
            resp = requests.get(url, headers=self.headers, timeout=20)
            resp.raise_for_status()
            data = resp.json()
            self.results = data.get("data", []) if isinstance(data, dict) else []
        except Exception as e:
            QMessageBox.critical(self, tr('ERROR'), tr('API_FAIL', error=str(e)))
            return

        layout = self.games_panel["layout"]
        group = self.games_panel["button_group"]

        # No results
        if not self.results:
            layout.addWidget(QLabel(tr('NO_RESULTS')))
            return

        # Create new radios
        for game in self.results:
            rb = QRadioButton(f"{game.get('id')} - {game.get('name')}")
            rb.setProperty("game_data", game)
            rb.toggled.connect(self.on_game_radio_toggled)
            group.addButton(rb)
            layout.addWidget(rb)

    def _clear_radio_panel(self, panel: dict):
        """Removes all radios and widgets from a radio panel."""
        group = panel["button_group"]
        layout = panel["layout"]

        # Remove buttons from group
        for btn in group.buttons():
            group.removeButton(btn)
            btn.deleteLater()

        # Remove widgets from the layout
        while layout.count():
            item = layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

    def _make_radio_panel_for_games(self):
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)

        container = QWidget()
        layout = QVBoxLayout(container)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(4)
        scroll.setWidget(container)

        group = QButtonGroup(self)
        group.setExclusive(True)

        return {
            "scroll": scroll,
            "container": container,
            "layout": layout,
            "button_group": group,
        }

    def on_game_radio_toggled(self, checked: bool):
        if not checked:
            return
        rb = self.sender()
        game = rb.property("game_data")
        if not game:
            return
        self.selected_game = game
        game_id = game.get("id")
        if game_id is not None:
            self._load_images_by_id(game_id)

    def _load_images_by_id(self, game_id: int):
        """Loads hero images via worker."""
        self.setEnabled(False)
        # Clear the image container
        for i in reversed(range(self.images_layout.count())):
            widget = self.images_layout.itemAt(i).widget()
            if widget:
                widget.setParent(None)
        self.transfer_button.setEnabled(False)

        # Infinite progress bar while loading
        self.progress_bar.setRange(0, 0)

        self.loader = HeroesLoader(self.api_key, game_id)
        self.loader.finished.connect(self.on_images_loaded)
        self.loader.error.connect(self.on_loader_error)
        self.loader.start()

    def on_loader_error(self, msg):
        self.setEnabled(True)
        # Reset the bar
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        QMessageBox.critical(self, tr("ERROR"), msg)

    def on_images_loaded(self, heroes):
        self.setEnabled(True)

        # Reset progress bar
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)

        self.heroes = heroes or []

        # Clear image container
        for i in reversed(range(self.images_layout.count())):
            widget = self.images_layout.itemAt(i).widget()
            if widget:
                widget.setParent(None)

        if not self.heroes:
            label = QLabel(tr('NO_HERO_IMAGES'))
            self.images_layout.addWidget(label)
            self.transfer_button.setEnabled(False)
            return

        for hero in self.heroes:
            row = QWidget()
            row_layout = QHBoxLayout(row)
            row_layout.setContentsMargins(0, 0, 0, 0)
            # Adjust spacing according to the current Qt style
            if QApplication.style().objectName().lower() == "oxygen":
                row_layout.setSpacing(0)  # Specific Spacing for Oxygen
            else:
                row_layout.setSpacing(8)  # Default Spacing

            # Checkbox on the left
            checkbox = QCheckBox()
            checkbox.setProperty("hero_data", hero)
            row_layout.addWidget(checkbox)

            # Image
            img_label = QLabel()
            if img_data := hero.get("img_data"):
                pixmap = QPixmap()
                pixmap.loadFromData(img_data)
                img_label.setPixmap(pixmap.scaled(
                    200, 90,
                    Qt.AspectRatioMode.KeepAspectRatio,
                    Qt.TransformationMode.SmoothTransformation
                ))
            row_layout.addWidget(img_label)

            # Name/ID next to image
            text_label = QLabel(f"ID {hero.get('id')}")
            text_label.setContentsMargins(8, 0, 0, 0)
            row_layout.addWidget(text_label)

            row_layout.addStretch()  # Maintains clean horizontal alignment

            self.images_layout.addWidget(row)

        self.transfer_button.setEnabled(True)

    def transfer_images(self):
        """Transfers the selected images."""
        if not self.selected_game:
            return

        to_transfer = []

        for i in range(self.images_layout.count()):
            row = self.images_layout.itemAt(i).widget()
            if not row:
                continue
            checkbox = row.findChild(QCheckBox)
            if checkbox and checkbox.isChecked():
                hero = checkbox.property("hero_data")
                if hero and hero.get("url"):
                    to_transfer.append(hero)

        if not to_transfer:
            QMessageBox.information(self, tr('APP_NAME'), tr('SELECT_AT_LEAST_ONE_IMAGE'))
            return

        self.setEnabled(False)

        game_name = (self.selected_game.get("name") or str(self.selected_game.get('id'))).replace("/", "_")
        save_dir = HEROES_DIR / game_name
        save_dir.mkdir(parents=True, exist_ok=True)

        # Pull-up bar
        self.progress_bar.setRange(0, len(to_transfer))
        self.progress_bar.setValue(0)

        for i, hero in enumerate(to_transfer, start=1):
            url = hero.get("url")
            try:
                r = requests.get(url, timeout=30)
                r.raise_for_status()
                ext = Path(url).suffix
                if not ext or len(ext) > 6:
                    ext = ".png"
                filename = save_dir / f"hero_{hero.get('id')}{ext}"
                with filename.open("wb") as f:
                    f.write(r.content)
            except Exception as e:
                print(tr("ERROR_TRANSFERRING_URL", url=url, error=e))

            self.progress_bar.setValue(i)
            QApplication.processEvents()

        # Reset bar
        self.progress_bar.setValue(100)
        QMessageBox.information(self, tr('DONE'), tr('TRANSFER_SUMMARY', len=len(to_transfer), dir=str(save_dir)))
        self.setEnabled(True)
        self.progress_bar.setValue(0)

if __name__ == "__main__":
    # Loads settings
    settings = load_settings()
    # Uses full saved locale, or LANG defined in the module (which already has 'pt_BR.UTF-8', for example)
    current_lang = settings.get("language", LANG)  
    LANG = current_lang  # Update the global variable
    app = QApplication(sys.argv)

    # Define the application ID so Wayland can find the icon.
    # We use the lowercase application name with hyphens instead of spaces.
    app_id = tr('APP_NAME').lower().replace(' ', '-')
    app.setDesktopFileName(app_id)

    window = Meganimus()
    window.show()
    sys.exit(app.exec())
